
<!-- > #### caution::甩锅声明
> 从PA4开始, 讲义中就不再提供滴水不漏的代码指导了,
> 部分关键的代码细节需要你自己去思考和尝试(我们故意省略的).
> 我们会在讲义中将技术的原理阐述清楚,
> 你需要首先理解这些原理, 然后根据理解来阅读并编写相应的代码.
>
> 一句话总结, 与其抱怨讲义写得不清楚, 还不如自己多多思考.
> 现在都到PA4了, 为了让成绩符合正态分布, 拿高分总需要多付出点努力吧.
> 如果你之前都是想办法投机取巧而不去深入理解系统如何工作, 现在应该已经没戏了. -->
> #### caution::Disclaimer of Passing the Buck
> Starting from PA4, the lecture notes will no longer provide watertight code guidance,
> and some key details of the code need to be considered and tried out by yourself (we deliberately omitted them).
> We will elucidate the principles of technology clearly in the lecture notes,
> and you need to first understand these principles, then read and write the corresponding code based on your understanding.
>
> In a nutshell, rather than complaining about the unclear lecture notes, it's better to think more on your own.
> Now that we've reached PA4, to conform the grades to a normal distribution, scoring high will inevitably require extra effort.
> If you have been looking for shortcuts rather than trying to deeply understand how the system works, it might be too late now.


<!-- ## 多道程序 -->
## Multiprogramming

<!-- 通过Nanos-lite的支撑, 我们已经在NEMU中成功运行了一个批处理系统, 并把仙剑奇侠传跑起来了!
这说明我们亲自构建的NEMU这个看似简单的机器, 同样能支撑真实程序的运行, 丝毫不逊色于真实的机器!
不过, 这个批处理系统目前还是只能同时运行一个程序,
只有当一个程序结束执行之后, 才会开始执行下一个程序. -->
With the support of Nanos-lite, we have successfully run a batch processing system in NEMU and got the game "The Legend of Sword and Fairy" up and running! This demonstrates that our self-built NEMU, though seemingly simple, is equally capable of supporting the execution of real programs, no less inferior to a real machine! However, the batch processing system currently can only run one program at a time, and it only starts executing the next program after one has finished.

<!-- 这也正是批处理系统的一个缺陷:
如果当前程序正在等待输入输出, 那么整个系统都会因此而停顿.
在真实的计算机中, 和CPU的性能相比, 输入输出是非常缓慢的:
以磁盘为例, 磁盘进行一次读写需要花费大约5毫秒的时间,
但对于一个2GHz的CPU来说, 它需要花费10,000,000个周期来等待磁盘操作的完成.
但事实上, 与其让系统陷入无意义的等待, 还不如用这些时间来进行一些有意义的工作.
一个简单的想法就是, 在系统一开始的时候加载多个程序, 然后运行第一个;
当第一个程序需要等待输入输出的时候, 就切换到第二个程序来运行;
当第二个程序也需要等待的时候, 就继续切换到下一个程序来运行, 如此类推. -->
This indeed highlights a flaw in the batch processing system: if the current program is waiting for input/output, the whole system will come to a halt. In real computers, compared to the CPU's performance, input/output operations are significantly slower. For example, a disk read/write operation takes about 5 milliseconds, but for a 2GHz CPU, this means waiting for 10,000,000 cycles for the disk operation to complete. However, instead of letting the system fall into a meaningless wait, it would be better to use this time to do some meaningful work. A simple idea is to load multiple programs at the beginning, then run the first one; when the first program needs to wait for input/output, switch to the second program to run; when the second program also needs to wait, continue to switch to the next program to run, and so on.

<!-- 这就是[多道程序(multiprogramming)][multiprogramming]系统的基本思想.
多道程序的想法听上去很简单, 但它也是一种多任务系统,
这是因为它已经包含了多任务系统的基本要素.
换句话说, 要实现一个多道程序操作系统,
我们只需要实现以下两点就可以了:
* 在内存中可以同时存在多个进程
* 在满足某些条件的情况下, 可以让执行流在这些进程之间切换 -->
This is the basic idea behind a [multiprogramming][multiprogramming] system. The concept of multiprogramming sounds simple, but it's also a form of multitasking system because it already includes the basic elements of a multitasking system. In other words, to implement a multiprogramming operating system, we only need to achieve the following two points:
* Multiple processes can coexist in memory at the same time
* Under certain conditions, it is possible to switch the execution flow among these processes


[multiprogramming]: https://en.wikipedia.org/wiki/Computer_multitasking#Multiprogramming

<!-- > #### hint::术语变更
> 既然是多任务系统, 系统中就运行的程序就不止一个了.
> 现在我们就可以直接使用"进程"的概念了. -->
> #### hint::Terminology Change
> Since it's a multitasking system, there is more than one program running in the system.
> Now, we can directly use the concept of "process".


<!-- 要实现第一点并不难, 我们只要让loader把不同的进程加载到不同的内存位置就可以了,
加载进程的过程本质上就是一些内存拷贝的操作, 因此并没有什么困难的地方. -->
Implementing the first point is not difficult; we simply need to have the loader load different processes into different memory locations. The process of loading processes is essentially a series of memory copy operations, so there is nothing particularly challenging about it.

<!-- > #### comment::其实我在骗你!
> 对我们目前实现的计算机系统来说, "把不同的进程加载到不同的内存位置"其实是一件很麻烦的事情,
> 你能想明白为什么吗? 如果想不明白也没关系, 我们会在下一阶段详细讨论这个问题. -->
> #### comment::Actually, I'm fooling you!
> For our currently implemented computer system, "loading different processes into different memory locations" is a troublesome task. Can you figure out why? If not, it's okay, we will discuss this issue in detail in the next stage.


<!-- 为了简单起见, 我们可以在操作系统中直接定义一些测试函数来作为程序,
因为程序本质上就是一些有意义的指令序列, 目前我们不必在意这些指令序列到底从何而来.
不过, 一个需要注意的地方是栈, 我们需要为每个进程分配各自的栈空间. -->
For simplicity, we can directly define some test functions in the operating system as programs, because essentially, a program is just a sequence of meaningful instructions, and for now, we don't need to worry about where these sequences come from. However, one thing to note is the stack; we need to allocate separate stack spaces for each process.

<!-- > #### question::为什么需要使用不同的栈空间?
> 如果不同的进程共享同一个栈空间, 会发生什么呢? -->
> #### question::Why do we need to use different stack spaces?
> What would happen if different processes shared the same stack space?

<!-- 反而需要深思熟虑的是第二点: 表面上看, "怎么让执行流在进程之间切换"并不是一件直观的事情. -->
The second point requires more thoughtful consideration: on the surface, "how to switch the execution flow among processes" is not an intuitive matter.

<!-- ## 上下文切换 -->
## Context Switch

<!-- 在PA3中, 我们已经提到了操作系统和用户进程之间的执行流切换,
并介绍了"上下文"的概念: 上下文的本质就是进程的状态.
换句话说, 我们现在需要考虑的是, 如何在多个用户进程之间进行上下文切换. -->
In PA3, we already discussed the switching of execution flow between the operating system and user processes, and introduced the concept of "context": the essence of context is the state of the process. In other words, what we now need to consider is how to switch contexts among multiple user processes.

<!-- 为了帮助大家理解这个问题, 我们在`am-kernels`中为大家准备了一个约30行的操作系统`yield-os`,
它创建了两个执行流, 在CTE的支撑下交替输出`A`和`B`.
你可以在`native`上运行`yield-os`来查看它的行为. -->
To help you understand this problem, we have prepared an operating system `yield-os` of about 30 lines in `am-kernels` for everyone. It creates two execution flows and alternately outputs `A` with the support of CTE  and `B`.
You can run `yield-os` on `native` to see how it behaves.

<!-- > #### danger::更新am-kernels
> 我们在2023年10月3日15:35:00在`am-kernels`中添加了`yield-os`的代码.
> 如果你在此时间前获取`am-kernels`的代码, 请通过以下命令获取更新后的代码: -->
> #### danger::Update am-kernels
> We added the `yield-os` code to `am-kernels` on October 3, 2023, at 15:35:00.
> If you acquired the `am-kernels` code before this time, please use the following command to get the updated code:
> ```bash
> cd am-kernels
> git pull origin master
> ```

<!-- ### 基本原理 -->
### Fundamental

<!-- 事实上, 有了CTE, 我们就有一种很巧妙的方式来实现上下文切换了.
具体地, 假设进程A运行的过程中触发了系统调用, 通过自陷指令陷入到内核.
根据`__am_asm_trap()`的代码, A的上下文结构(`Context`)将会被保存到A的栈上.
在PA3中, 系统调用处理完毕之后, `__am_asm_trap()`会根据栈上保存的上下文结构来恢复A的上下文.
神奇的地方来了, 如果我们先不着急恢复A的上下文,
而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢?
由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文.
从`__am_asm_trap()`返回之后, 我们已经在运行进程B了! -->
In fact, with CTE (Context and Trap Extension), we have a clever way to implement context switching.
Specifically, suppose process A triggers a system call during execution and enters the kernel through a trap instruction.
According to the code in `__am_asm_trap()`, A's context structure (`Context`) will be saved on A's stack.
In PA3, after the system call is handled, `__am_asm_trap()` will restore A's context based on the context structure saved on the stack.
Here comes the magic part: what if we don't rush to restore A's context,
but instead, switch the stack pointer to another process B's stack?
Since B's stack contains the previously saved context structure of B, the subsequent operations will restore B's context based on this structure.
After returning from `__am_asm_trap()`, we are now running process B!


![context-switch](./images/Context-switch.png)

<!-- 那进程A到哪里去了呢? 别担心, 它只是被暂时"挂起"了而已.
在被挂起之前, 它已经把上下文结构保存到自己的栈上了,
如果将来的某一时刻栈顶指针被切换到A的栈上,
代码将会根据栈上的上下文结构来恢复A的上下文, A将得以唤醒并执行.
所以, 上下文切换其实就是不同进程之间的栈切换! -->
So where did process A go? Don't worry, it was just "suspended" temporarily.
Before being suspended, it saved the context structure on its stack. If the top pointer of the stack is switched to A's stack at some point in the future, the code will restore A's context based on the context structure on the stack. A will be awakened and executed.
Therefore, context switching is a stack switching between different processes!

<!-- ### 进程控制块 -->
### Process Control Block

<!-- 但是, 我们要如何找到别的进程的上下文结构呢?
注意到上下文结构是保存在栈上的, 但栈空间那么大,
受到函数调用形成的栈帧的影响, 每次保存上下文结构的位置并不是固定的.
自然地, 我们需要一个`cp`指针(context pointer)来记录上下文结构的位置,
当想要找到其它进程的上下文结构的时候, 只要寻找这个进程相关的`cp`指针即可. -->
However, how do we locate the context structure of another process?
Notice that the context structure is saved on the stack, and the stack space is vast.
Affected by the stack frames formed by function calls, the location where the context structure is saved is not fixed each time.
Naturally, we need a `cp` (context pointer) to record the location of the context structure.
When we want to find the context structure of another process, we just need to look for the `cp` pointer related to that process.


<!-- 事实上, 有不少信息都是进程相关的,
除了刚才提到的上下文指针`cp`之外, 上文提到的栈空间也是如此.
为了方便对这些进程相关的信息进行管理,
操作系统使用一种叫进程控制块(PCB, process control block)的数据结构, 为每一个进程维护一个PCB.
`yield-os`的代码中已经定义了我们所需要使用的PCB结构: -->
In fact, many pieces of information are process-related,
including the context pointer `cp` mentioned earlier, as well as the stack space discussed above.
To facilitate the management of these process-related pieces of information,
the operating system uses a data structure called the Process Control Block (PCB), maintaining a PCB for each process.
The PCB structure that we need to use has already been defined in the code of `yield-os`:
```c
typedef union {
  uint8_t stack[STACK_SIZE];
  struct {
    Context *cp;
  };
} PCB;
```

<!-- 代码使用一个联合体来把其它信息放置在进程堆栈的底部.
代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了, 不会出现栈溢出导致UB.
在进行上下文切换的时候, 只需要把PCB中的`cp`指针返回给CTE的`__am_irq_handle()`函数即可,
剩余部分的代码会根据上下文结构恢复上下文.
我们只要稍稍借助数学归纳法, 就可以让我们相信这个过程对于正在运行的进程来说总是正确的.

那么, 对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢? -->
The code uses a union to place other information at the bottom of the process stack.
Each process is allocated a 32KB stack, which is sufficient to prevent stack overflow leading to undefined behavior (UB).
During context switching, all that needs to be done is to return the `cp` pointer from the PCB to the CTE's `__am_irq_handle()` function,
and the remaining part of the code will restore the context based on the context structure.
With just a bit of mathematical induction, we can be confident that this process is always correct for the processes that are running.

So, how do we switch to a process that has just been loaded, to get it running?


<!-- ### 内核线程 -->
### Kernel thread

<!-- #### 创建内核线程上下文 -->
#### Create kernel thread context

<!-- 答案很简单, 我们只需要在进程的栈上人工创建一个上下文结构,
使得将来切换的时候可以根据这个结构来正确地恢复上下文即可. -->
The answer is simple, we only need to manually create a context structure on the process stack so that the context can be correctly restored based on this structure when switching in the future.

<!-- 上文提到, 我们先把操作系统中直接定义的一些测试函数作为程序.
`yield-os`提供了一个测试函数`f()`,
我们接下来的任务就是为它创建一个上下文, 然后切换到它来执行.
这样的执行流有一个专门的名称, 叫"内核线程"(kernel thread). -->
As mentioned earlier, we start by using some test functions directly defined in the operating system as programs.
`yield-os` provides a test function `f()`,
and our next task is to create a context for it, and then switch to it for execution.
This type of execution flow has a specific name, called a "kernel thread."


<!-- > #### comment::为什么不叫"内核进程"?
> 这个问题其实等价于"进程和线程有什么区别", 是个不错的问题.
> 而且这还属于考研八股的内容呢, 于是你肯定可以通过STFW找到很多五花八门的答案,
> 比如"线程更加轻量级", "线程没有独立的资源"等等.
>
> 如果要进一步解释"什么是轻量级", "独立的资源是什么意思", 在PA中可能比较困难.
> 不过在PA中也不必深究这个问题, 目前你只需要把它们都看成执行流就可以了,
> 更重要的是, 这两者你都将会实现, 在代码中亲自去感受它们的区别不是一个更好的选择吗?
> 另外, 带着这个问题去修读下学期的操作系统课也不错. -->
> #### comment::Why not call it "kernel process"?
> This question is essentially equivalent to "What is the difference between a process and a thread", which is a good question.
> Moreover, this also falls under the typical content for graduate entrance exams, so you can find a variety of answers by searching the web (STFW),
> such as "Threads are more lightweight", "Threads do not have independent resources" and so on.
>
> If you want to further explain "what does lightweight mean" and "what are independent resources," it might be difficult in the context of PA.
> However, in PA, it is not necessary to delve deeply into this issue; for now, you can simply consider them both as streams of execution.
> More importantly, you will implement both, and isn't experiencing their differences firsthand in code a better choice?
> Additionally, taking this question into next semester's operating systems course might be a good idea.


<!-- 创建内核线程的上下文是通过CTE提供的`kcontext()`函数
(在`abstract-machine/am/src/$ISA/nemu/cte.c`中定义)来实现的,
其中的"k"代表内核. `kcontext()`的原型是 -->
Creating the context for a kernel thread is implemented through the `kcontext()` function provided by CTE,
which is defined in `abstract-machine/am/src/$ISA/nemu/cte.c`,
where "k" stands for kernel. The prototype of `kcontext()` is:
```c
Context* kcontext(Area kstack, void (*entry)(void *), void *arg);
```
<!-- 其中`kstack`是栈的范围, `entry`是内核线程的入口, `arg`则是内核线程的参数.
此外, `kcontext()`要求内核线程不能从`entry`返回, 否则其行为是未定义的.
你需要在`kstack`的底部创建一个以`entry`为入口的上下文结构(目前你可以先忽略`arg`参数),
然后返回这一结构的指针. -->
In this, `kstack` defines the range of the stack, `entry` is the entry point for the kernel thread, and `arg` is the parameter for the kernel thread.
Additionally, `kcontext()` requires that the kernel thread must not return from `entry`, as this would result in undefined behavior.
You need to create a context structure at the bottom of `kstack` with `entry` as the entry point (you can ignore the `arg` parameter for now),
and then return the pointer to this structure.


<!-- `yield-os`会调用`kcontext()`来创建上下文, 并把返回的指针记录到PCB的`cp`中: -->
`yield-os` calls `kcontext()` to create a context and records the returned pointer in the PCB's `cp` field:
```
|               |
+---------------+ <---- kstack.end
|               |
|    context    |
|               |
+---------------+ <--+
|               |    |
|               |    |
|               |    |
|               |    |
+---------------+    |
|       cp      | ---+
+---------------+ <---- kstack.start
|               |
```

<!-- #### 线程/进程调度 -->
#### Thread/Process scheduling

<!-- 上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文,
则是由操作系统来决定的, 这项任务叫做进程调度.
进程调度是由`schedule()`函数来完成的, 它用于返回将要调度的进程上下文.
因此, 我们需要一种方式来记录当前正在运行哪一个进程,
这样我们才能在`schedule()`中返回另一个进程的上下文, 以实现多任务的效果.
这一工作是通过`current`指针来实现的, 它用于指向当前运行进程的PCB.
这样, 我们就可以在`schedule()`中通过`current`来决定接下来要调度哪一个进程了.
不过在调度之前, 我们还需要把当前进程的上下文指针保存在PCB当中: -->
The creation and switching of contexts is the responsibility of the CTE, while deciding which context to switch to is determined by the operating system, a task known as process scheduling.
Process scheduling is accomplished by the `schedule()` function, which is used to return the context of the process to be scheduled.
Therefore, we need a way to track which process is currently running,
so that we can return the context of another process in `schedule()`, achieving multitasking.
This is done using the `current` pointer, which points to the PCB of the currently running process.
This way, we can decide which process to schedule next using `current` in `schedule()`.
However, before scheduling, we also need to save the current process's context pointer in its PCB:

```c
// save the context pointer
current->cp = prev;

// switch between pcb[0] and pcb[1]
current = (current == &pcb[0] ? &pcb[1] : &pcb[0]);

// then return the new context
return current->cp;
```
<!-- 目前我们让`schedule()`总是切换到另一个进程.
注意所选进程的上下文是通过`kcontext()`创建的,
在`schedule()`中才决定要切换到它, 然后在CTE的`__am_asm_trap()`中才真正地恢复这一上下文. -->
Currently, we have `schedule()` always switch to another process.
Note that the context of the chosen process is created by `kcontext()`,
and it is only decided in `schedule()` to switch to it, then the context is actually restored in CTE’s `__am_asm_trap()`.

<!-- > #### comment::机制和策略解耦
> 这其实体现了系统设计中的一种重要原则: 机制和策略解耦.
> 机制解决的是"能不能做"的问题, 而策略解决的则是"怎么做好"的问题.
> 显然, 策略需要机制的支撑, 机制需要策略来发挥最大的效果.
>
> 解耦的好处就很明显了: 代码重用率高, 而且容易理解.
> 在Project-N中, 这一解耦几乎做到了极致: 机制和策略被分离到两个子项目中.
> 比如, "上下文切换"这一机制是在AM的CTE中实现的, 它让系统可以做到"执行流的切换"这件事;
> 而具体要切换到哪一个执行流, 则是在操作系统中实现的.
>
> AM的另外一个好处是将底层硬件的行为抽象成系统级机制,
> AM上的应用(包括OS)只需要调用这些系统级机制, 并实现相应的策略即可.
> 当然目前`schedule()`中的策略非常简单, 下学期的操作系统实验,
> 甚至是现实中更复杂的进程调度策略, 都可以在AM提供的同一个机制之上实现. -->
> #### comment::Decoupling Mechanisms and Policies
> This actually reflects an important principle in system design: the decoupling of mechanisms and policies.
> Mechanisms address the question of "can it be done," while policies address the question of "how to do it well."
> Clearly, policies rely on mechanisms, and mechanisms need policies to be most effective.
>
> The benefits of decoupling are obvious: high code reusability and ease of understanding.
> In Project-N, this decoupling has been taken to the extreme: mechanisms and policies are separated into two sub-projects.
> For example, the "context switching" mechanism is implemented in the AM's CTE, which enables the system to "switch execution streams";
> which specific execution stream to switch to, however, is implemented in the operating system.
>
> Another advantage of AM is that it abstracts the behavior of the underlying hardware into system-level mechanisms,
> Applications on AM (including OS) only need to call these system-level mechanisms and implement corresponding policies.
> Currently, the strategy in `schedule()` is quite simple, but next semester's operating system lab,
> and even more complex real-world process scheduling strategies, can all be implemented on the same mechanism provided by AM.


<!-- > #### todo::实现上下文切换
> 根据讲义的上述内容, 实现以下功能:
> * CTE的`kcontext()`函数
> * 修改CTE中`__am_asm_trap()`的实现, 使得从`__am_irq_handle()`返回后,
> 先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文, 从而完成上下文切换的本质操作
>
> 正确实现后, 你将看到`yield-os`不断输出`?`, 这是因为我们还没有为`kcontext()`实现参数功能,
> 不过这些输出的`?`至少说明了CTE目前可以正确地从`yield-os`的`main()`函数切换到其中一个内核线程. -->
> #### todo::Implement Context Switching
> Based on the content in the lecture notes, implement the following functions:
> * The `kcontext()` function in CTE
> * Modify the implementation of `__am_asm_trap()` in CTE so that after returning from `__am_irq_handle()`,
>   the stack pointer is first switched to the new process's context structure, and then the context is restored,
>   thus completing the essential operation of context switching.
>
> Once implemented correctly, you will see `yield-os` continuously outputting `?`, which is because we have not yet implemented the parameter functionality for `kcontext()`,
> but these outputs of `?` at least demonstrate that CTE can currently correctly switch from the `yield-os` main() function to one of its kernel threads.


<!-- > #### hint::关于kcontext()的提示
> 我们希望代码将来从``__am_asm_trap()``返回之后, 就会开始执行`f()`.
> 换句话说, 我们需要在`kcontext()`中构造一个上下文, 它指示了一个状态,
> 从这个状态开始, 可以正确地开始执行`f()`.
> 所以你需要思考的是, 为了可以正确地开始执行`f()`,
> 这个状态究竟需要满足什么样的条件?
>
> 至于"先将栈顶指针切换到新进程的上下文结构", 很自然的问题就是,
> 新进程的上下文结构在哪里? 怎么找到它? 又应该怎么样把栈顶指针切换过去?
> 如果你发现代码跑飞了, 不要忘记, 程序是个状态机. -->
> #### hint::About kcontext()
> We want the code to start executing `f()` after returning from `__am_asm_trap()`.
> In other words, we need to construct a context in `kcontext()` that indicates a state
> from which `f()` can be correctly started.
> So what you need to consider is, in order to start executing `f()` correctly,
> what conditions should this state meet?
>
> As for "switching the stack pointer to the new process's context structure" 
> The natural question is, where is the new process's context structure? 
> How do we find it? And how should we switch the stack pointer to it?
> If you find the code going astray, don't forget, that the program is a state machine.


<!-- > #### hint::配合DiffTest
> 为了保证DiffTest的正确运行, 根据你选择的ISA, 你还需要进行一些额外的设置:
> * x86: 把上下文结构中的`cs`设置为`8`.
> * riscv32: 把上下文结构中的`mstatus`设置为`0x1800`.
> * riscv64, 把上下文结构中的`mstatus`设置为`0xa00001800`. -->
> #### hint::Working with DiffTest
> To ensure DiffTest runs correctly, you need to make some additional settings based on the ISA you've chosen:
> * For x86: Set `cs` in the context structure to `8`.
> * For riscv32: Set `mstatus` in the context structure to `0x1800`.
> * For riscv64: Set `mstatus` in the context structure to `0xa00001800`.

<!-- #### 内核线程的参数 -->
#### Kernel thread parameters

<!-- 为了让`yield-os`的内核线程可以正确输出字符, 我们需要通过`kcontext()`给`f()`传参.
于是我们需要继续思考, `f()`将会如何读出它的参数?
噢, 这不就是调用约定的内容吗? 你已经非常熟悉了.
我们只需要让`kcontext()`按照调用约定将`arg`放置在正确的位置,
将来`f()`执行的时候就可以获取正确的参数了. -->
To enable `yield-os`'s kernel threads to output characters correctly, we need to pass arguments to `f()` through `kcontext()`.
So we need to continue thinking about how `f()` will read its arguments.
Oh, isn't this about calling conventions? You're already very familiar with them.
We just need to ensure that `kcontext()` places `arg` in the correct position according to the calling convention,
so that when `f()` is executed, it can obtain the correct arguments.

> #### question::mips32和riscv32的调用约定
> 我们没有给出mips32和riscv32的调用约定, 你需要查阅相应的ABI手册.
> 当然, 你也可以自己动手实践来总结传参的规则.
> #### question::Calling conventions for MIPS32 and RISC-V32
> We haven't provided the calling conventions for MIPS32 and RISCV32. You'll need to read the corresponding ABI manuals.
> Of course, you can also experiment on your own to summarize the rules for passing arguments.

<!-- > #### todo::实现上下文切换(2)
> 根据讲义的上述内容, 修改CTE的`kcontext()`函数, 使其支持参数`arg`的传递.
>
> 因为`f()`中每次输出完信息都会调用`yield()`, 因此只要我们正确实现内核线程的参数传递,
> 就可以观察到`yield-os`在两个内核线程之间来回切换的现象.

在真实的操作系统中, 内核中的很多后台任务, 守护服务和驱动程序都是以内核线程的形式存在的.
如果你执行`ps aux`, 你就会看到系统中有很多COMMAND中带有中括号的内核线程(例如`[kthreadd]`).
而创建和执行它们的原理, 也是和上面的实验内容非常相似(当然具体实现肯定会有所不同). -->
> #### todo::Implement Context Switching (2)
> Based on the content provided in the lecture, modify the `kcontext()` function in CTE to support passing the argument `arg`.
>
> Since `f()` calls `yield()` after printing each message, once we correctly implement passing arguments to kernel threads,
> we should observe the phenomenon of `yield-os` switching back and forth between two kernel threads.

In real operating systems, many background tasks, daemon services, and drivers in the kernel exist in the form of kernel threads.
If you execute `ps aux`, you'll see many kernel threads with square brackets in the COMMAND column (e.g., `[kthreadd]`).
The principles behind creating and executing them are very similar to the experimental content above (although the specific implementation will certainly differ).

<!-- > #### option::保持kcontext()的特性
> AM在定义`kcontext()`的行为时, 还要求`kcontext()`只能在栈上放置一个上下文结构,
> 而不能放置更多的内容. 这样的要求有两点好处:
> * `kcontext()`对栈的写入只有一个上下文结构的内容, 而不会产生其它的副作用
> * OS可以预测调用`kcontext()`之后的返回值, 并且利用这一确定的特性进行一些检查或者简化某些实现 -->
> #### option::Preserve the Characteristics of kcontext()
> When defining the behavior of `kcontext()`, AM also requires that `kcontext()` can only place one context structure on the stack, 
> and cannot place more content. This requirement has two benefits:
> * `kcontext()` writes only one context structure to the stack, without causing any other side effects.
> * The OS can predict the return value after calling `kcontext()`, and can utilize this deterministic feature for checks or to simplify certain implementations.
>
<!-- > 我们知道x86是通过栈来传递参数的, 如果`kcontext()`需要支持`arg`的传递,
> 它就需要往栈上放置更多的内容, 这样就违反了上述确定性了.
> 但在PA中, 这并不会导致致命的问题, 因此我们并不要求你的`kcontext()`实现严格遵守这一确定性.
> 但你还是可以思考如何在遵守确定性的情况下实现参数的传递. -->
> We know that x86 passes parameters through the stack. If `kcontext()` needs to support passing `arg`, 
> it will need to place more content on the stack, thus violating the aforementioned determinism.
> However, in the PA, this won't lead to fatal issues, so we don't strictly require your `kcontext()` implementation to adhere to this determinism.
> Nevertheless, you can still consider how to implement parameter passing while adhering to determinism.
>
<!-- > 一个解决方案是通过引入一个辅助函数来将真正的参数传递从`kcontext()`推迟到内核线程的运行时刻.
> 具体地, 我们可以在`kcontext()`中先把内核线程的入口设置为辅助函数,
> 并把参数设置到某个可用的寄存器中. 这样以后, 内核线程就会从辅助函数开始执行,
> 此时让辅助函数来把之前设置的参数从寄存器中放置到栈上, 再调用真正的线程入口函数(`f()`).
> 这一方案和Linux中加载用户程序还是有一些相似之处的:
> 用户程序在运行的时候也并不是直接把`main()`函数作为入口,
> 而是先从CRT定义的``_start()``开始运行, 进行包括设置参数在内的一系列初始化操作,
> 最后才调用`main()`函数. -->
> One solution is to introduce a helper function to defer the passing of actual parameters from `kcontext()` to the runtime of the kernel thread.
> Specifically, we can set the entry point of the kernel thread to the helper function in `kcontext()`,
> and set the parameters to some available registers. Later, when the kernel thread starts executing,
> the helper function will place the previously set parameters from the registers onto the stack and then call the actual thread entry function (`f()`).
> This solution bears some resemblance to loading user programs in Linux:
> User programs don't directly start from the `main()` function; instead, they start from `_start()` defined in the CRT, 
> which performs a series of initialization operations including setting parameters, before finally calling `main()`.
>
<!-- > 如果你选择的ISA是x86, 你可以尝试在CTE中实现上述辅助函数.
> 考虑到要直接操作寄存器和栈, 这个辅助函数还是通过汇编代码来编写比较合适.
> 不过由于这个辅助函数的功能比较简单, 你只需要编写几条指令就可以实现它了. -->
> If you've chosen x86 as your ISA, you can try implementing the aforementioned helper function in CTE.
> Considering that it involves directly manipulating registers and the stack, it's more appropriate to write this helper function in assembly code.
> However, since the functionality of this helper function is relatively simple, you only need to write a few instructions to implement it.

<!-- ## OS中的上下文切换

`yield-os`是一个很小的OS, 除了上下文切换之外, 不具备其他功能,
但它可以帮助我们专注于理解上下文切换的核心细节.
理解这些细节后, 我们也可以很快将这些原理迁移到更大的OS中. -->
## Context Switching in Operating Systems

`yield-os` is a tiny OS that lacks functionality beyond context switching. However, it serves as a valuable tool for focusing on the core details of context switching. Once we grasp these details, we can swiftly apply these principles to larger operating systems.

<!-- ### RT-Thread(选做)

RT-Thread是一个流行的商业级嵌入式实时OS, 具备完善的OS功能模块,
可以适配各种不同的开发板, 并支撑各种应用程序的运行. -->
### RT-Thread (Optional)

RT-Thread is a popular commercial-grade embedded real-time operating system (RTOS) with comprehensive OS functional modules. It can be adapted to various development boards and support the execution of various application programs.

<!-- RT-Thread中有两个抽象层, 一个是BSP(Board Support Package), 另一个是libcpu.
BSP为各种型号的板卡定义了一套公共的API, 并基于这套API实现RT-Thread内核;
而对于一款板卡, 只需要实现相应的API, 就可以将RT-Thread内核运行在这款板卡上.
libcpu则是为各种CPU架构定义了一套公共的API, RT-Thread内核也会调用其中的某些API.
这一思想和AM非常类似. 当然, BSP也不仅仅是针对真实的板卡, 也可以对应QEMU等模拟器,
毕竟RT-Thread内核无需关心底层是否是一个真实的板卡. -->
RT-Thread has two abstraction layers: BSP (Board Support Package) and libcpu (CPU Support Package).
BSP defines a common API for various types of development boards and implements the RT-Thread kernel based on this API.
For a particular development board, only the corresponding API needs to be implemented to run the RT-Thread kernel on that board.
libcpu defines a common API for various CPU architectures, and the RT-Thread kernel also calls certain APIs from it.
This design philosophy is very similar to AM (Abstract Machine). Of course, BSP is not only for real development boards but also applicable to simulators like QEMU, as the RT-Thread kernel does not need to be concerned about whether the underlying platform is a real development board.

<!-- 我们把RT-Thread移植到AM上, 编译运行这个RT-Thread的步骤如下:
1. 以通过以下命令获取移植之后的RT-Thread:
   ```bash
   cd ~/Templates  # 在另一个目录下克隆代码, 因为RT-Thread的代码无需打包提交
   git clone git@github.com:NJU-ProjectN/rt-thread-am.git
   ```
1. 为了编译代码, 你还需要安装项目构建工具`scons`:
   ```bash
   apt-get install scons
   ```
1. 在`rt-thread-am/bsp/abstract-machine/`目录下执行`make init`, 进行一些编译前的准备工作,
   此命令只需执行一次即可, 后续编译运行前无需再次执行
1. 在相同目录下通过`make ARCH=native`等方式编译或运行RT-Thread, 默认的运行输出如下: -->
To compile and run RT-Thread after porting it to AM, follow these steps:

1. Clone the ported RT-Thread repository by executing the following command in a different directory, as RT-Thread's code does not need to be packaged and submitted:
   ```bash
   cd ~/Templates
   git clone git@github.com:NJU-ProjectN/rt-thread-am.git
   ```

2. To compile the code, you also need to install the project build tool `scons`:
   ```bash
   apt-get install scons
   ```

3. Execute `make init` in the `rt-thread-am/bsp/abstract-machine/` directory to perform some pre-compilation preparations. This command only needs to be executed once, and does not need to be executed again before subsequent compilation and execution.

4. Compile or run RT-Thread in the same directory using commands like `make ARCH=native`. The default output of the execution is as follows:
   ```
   heap: [0x01000000 - 0x09000000]

    \ | /
   - RT -     Thread Operating System
    / | \     5.0.1 build Oct  2 2023 20:51:10
    2006 - 2022 Copyright by RT-Thread team
   Assertion fail at rt-thread-am/bsp/abstract-machine/src/context.c:29
   ```
   <!-- 运行后触发了assertion, 这是因为代码中有部分功能需要大家实现. -->
   After running, the assertion is triggered. This is because some functions in the code need to be implemented by everyone.

<!-- 我们去掉了原项目中所有BSP和libcpu, 然后添加了一个特殊的BSP,
并用AM的API来实现BSP的API, 具体见`rt-thread-am/bsp/abstract-machine/`目录下的代码.
用到的AM API如下:
* 用TRM的heap实现RT-Thread中的堆
* 用TRM的`putch()`实现RT-Thread中的串口输出功能
* 暂不使用IOE
* 用CTE的`iset()`实现RT-Thread中开/关中断功能
* 通过CTE实现RT-Thread中上下文的创建和切换功能.
  此部分代码并未实现, 我们将它作为选做作业. -->
We removed all BSPs and libcpus from the original project, and then added a special BSP, and used AM's API to implement BSP's API. For details, see the code in the `rt-thread-am/bsp/abstract-machine/` directory. The AM APIs used are as follows:
* Use TRM's heap to implement the heap in RT-Thread
* Use TRM's `putch()` to implement the serial port output function in RT-Thread
* Do not use IOE for now
* Use CTE's `iset()` to implement the on/off interrupt function in RT-Thread
* Use CTE to implement the context creation and switching function in RT-Thread.
This part of the code is not implemented, we will use it as optional homework.

<!-- 对于上下文的创建, 你需要实现`rt-thread-am/bsp/abstract-machine/src/context.c`中的`rt_hw_stack_init()`函数: -->
For context creation, you need to implement the `rt_hw_stack_init()` function in `rt-thread-am/bsp/abstract-machine/src/context.c`:
```c
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit);
```
<!-- 它的功能是以`stack_addr`为栈底创建一个入口为`tentry`, 参数为`parameter`的上下文,
并返回这个上下文结构的指针. 此外, 若上下文对应的内核线程从`tentry`返回, 则调用`texit`,
RT-Thread会保证代码不会从`texit`中返回. -->
Its function is to create a context with entry `tentry` and parameter `parameter` as the bottom of the stack with `stack_addr` as the bottom, and return the pointer of this context structure. In addition, if the kernel thread corresponding to the context returns from `tentry`, `texit` is called, and RT-Thread will ensure that the code will not return from `texit`.
<!-- 需要注意:
1. 传入的`stack_addr`可能没有任何对齐限制, 最好将它对齐到`sizeof(uintptr_t)`再使用.
2. CTE的`kcontext()`要求不能从入口返回, 因此需要一种新的方式来支持`texit`的功能.
   一种方式是构造一个包裹函数, 让包裹函数来调用`tentry`, 并在`tentry`返回后调用`texit`,
   然后将这个包裹函数作为`kcontext()`的真正入口, 不过这还要求我们将`tentry`,
   `parameter`和`texit`这三个参数传给包裹函数, 应该如何解决这个传参问题呢? -->
Note:
1. The passed `stack_addr` may not have any alignment restrictions, so it is best to align it to `sizeof(uintptr_t)` before using it.
2. CTE's `kcontext()` requires that it cannot return from the entry point, so a new way is needed to support the `texit` function.
One way is to construct a wrapper function, let the wrapper function call `tentry`, and call `texit` after `tentry` returns,
and then use this wrapper function as the real entry point of `kcontext()`. However, this also requires us to pass the three parameters of `tentry`,
`parameter` and `texit` to the wrapper function. How should we solve this parameter-passing problem?

<!-- 对于上下文的切换, 你需要实现`rt-thread-am/bsp/abstract-machine/src/context.c`中的`rt_hw_context_switch_to()`函数和`rt_hw_context_switch()`函数: -->
For context switching, you need to implement the `rt_hw_context_switch_to()` and `rt_hw_context_switch()` functions in `rt-thread-am/bsp/abstract-machine/src/context.c`:
```c
void rt_hw_context_switch_to(rt_ubase_t to);
void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to);
```
<!-- 其中`rt_ubase_t`类型其实是`unsigned long`, `to`和`from`都是指向上下文指针变量的指针(二级指针).
`rt_hw_context_switch_to()`用于切换到`to`指向的上下文指针变量所指向的上下文,
而`rt_hw_context_switch()`还需要额外将当前上下文的指针写入`from`指向的上下文指针变量中.
为了进行切换, 我们可以通过`yield()`触发一次自陷,
在事件处理回调函数`ev_handler()`中识别出`EVENT_YIELD`事件后, 再处理`to`和`from`.
同样地, 我们需要思考如何将`to`和`from`这两个参数传给`ev_handler()`.
在`rt-thread-am/bsp/abstract-machine/src/context.c`中还有一个`rt_hw_context_switch_interrupt()`函数,
不过目前RT-Thread的运行过程不会调用它, 因此目前可以忽略它. -->
The `rt_ubase_t` type is actually `unsigned long`, and `to` and `from` are pointers to context pointer variables (secondary pointers).
`rt_hw_context_switch_to()` is used to switch to the context pointed to by the context pointer variable pointed to by `to`,
and `rt_hw_context_switch()` also needs to write the current context pointer to the context pointer variable pointed to by `from`.
In order to switch, we can trigger a self-trap through `yield()`,
and then process `to` and `from` after identifying the `EVENT_YIELD` event in the event processing callback function `ev_handler()`.
Similarly, we need to think about how to pass the two parameters `to` and `from` to `ev_handler()`.
There is also a `rt_hw_context_switch_interrupt()` function in `rt-thread-am/bsp/abstract-machine/src/context.c`,
but it will not be called during the current RT-Thread operation, so it can be ignored for now.

<!-- 根据分析, 上面两个功能的实现都需要处理一些特殊的参数传递问题.
对于上下文的切换, 以`rt_hw_context_switch()`为例,
我们需要在`rt_hw_context_switch()`中调用`yield()`, 然后在`ev_handler()`中获得`from`和`to`.
`rt_hw_context_switch()`和`ev_handler()`是两个不同的函数, 但由于CTE机制的存在,
使得`rt_hw_context_switch()`不能直接调用`ev_handler()`.
因此, 一种直接的方式就是借助全局变量来传递信息. -->
According to the analysis, the implementation of the above two functions needs to deal with some special parameter-passing issues.
For context switching, taking `rt_hw_context_switch()` as an example,
we need to call `yield()` in `rt_hw_context_switch()`, and then get `from` and `to` in `ev_handler()`.
`rt_hw_context_switch()` and `ev_handler()` are two different functions, but due to the existence of the CTE mechanism,
`rt_hw_context_switch()` cannot directly call `ev_handler()`.
Therefore, a direct way is to use global variables to pass information.

<!-- > #### danger::危险的全局变量
> 全局变量在整个系统中只有一个副本, 如果整个系统中只有一个线程, 这通常是安全的.
> 我们在C语言课上编写的程序都属于这种情况, 所以使用全局变量并不会造成明显的正确性问题.
> 但如果系统中存在多个线程, 并且它们使用同一个全局变量的时间段有重叠, 就可能会造成问题.
>
> 不过目前我们的硬件既未实现中断, 也不支持多处理器,
> 从编程模型来看和C语言课差不多, 因此使用全局变量解决这个问题还是可以的. -->
> #### danger::Dangerous global variables
> Global variables have only one copy in the entire system, which is usually safe if there is only one thread in the entire system.
> The programs we wrote in the C language class all belong to this situation, so using global variables does not cause obvious correctness problems.
> But if there are multiple threads in the system and their periods of using the same global variable overlap, it may cause problems.
>
> However, our hardware currently does not implement interrupts or support multiple processors,
> From the programming model point of view, it is similar to the C language class, so it is still possible to use global variables to solve this problem.


<!-- > #### question::危险的全局变量(2)
> 如果使用全局变量来传递信息, 考虑以下场景, 可能会出现什么问题?
> * 在多处理器系统中, 两个处理器同时调用`rt_hw_context_switch()`
> * 一个线程调用`rt_hw_context_switch()`后写入了全局变量, 但马上到来了时钟中断,
>   使得系统切换到另一个线程, 但这个线程也调用了`rt_hw_context_switch()` -->
> #### question::Dangerous global variables (2)
> If global variables are used to pass information, consider the following scenarios, what problems may occur?
> * In a multi-processor system, two processors call `rt_hw_context_switch()` at the same time
> * A thread calls `rt_hw_context_switch()` and writes to the global variable, but a clock interrupt arrives immediately,
> causing the system to switch to another thread, but this thread also calls `rt_hw_context_switch()`

<!-- 但对于上下文的创建, 问题就更复杂了: 调用`rt_hw_stack_init()`和执行包裹函数的两个线程并不相同. -->
But for context creation, the problem is more complicated: the two threads calling `rt_hw_stack_init()` and executing the wrapper function are not the same.

<!-- > #### question::危险的全局变量(3)
> 如果使用全局变量来传递信息, 而代码连续调用了两次`rt_hw_stack_init()`, 会造成什么问题? -->
> #### question::Dangerous global variables (3)
> If global variables are used to pass information, and the code calls `rt_hw_stack_init()` twice in a row, what problems will arise?

<!-- 因此, 我们需要寻找另一种解决方案.
回过头来看, 全局变量造成问题的原因是它会被多个线程共享,
为了得到正确的解决方案, 我们应该反其道而行之: 使用一种不会被多个线程共享的存储空间.
嘿嘿, 其实前文已经提到过它了, 那就是栈!
我们只需要让`rt_hw_stack_init()`将包裹函数的三个参数放在上下文的栈中,
将来包裹函数执行的时候就可以从栈中取出这三个参数, 而且系统中的其他线程都不能访问它们. -->
Therefore, we need to find another solution.
Looking back, the reason why global variables cause problems is that they are shared by multiple threads.
In order to get the right solution, we should do the opposite: use a storage space that is not shared by multiple threads.
Hey, in fact, it has been mentioned in the previous article, that is the stack!
We just need to let `rt_hw_stack_init()` put the three parameters of the wrapper function in the context stack,
and in the future, when the wrapper function is executed, these three parameters can be taken out of the stack, and other threads in the system cannot access them.

<!-- 最后还需要考虑参数数量的问题, `kcontext()`要求入口函数只能接受一个类型为`void *`的参数.
不过我们可以自行约定用何种类型来解析这个参数(整数, 字符, 字符串, 指针等皆可),
于是这就成了一个C语言的编程题了. -->
Finally, we need to consider the number of parameters. `kcontext()` requires that the entry function can only accept a parameter of type `void *`.
However, we can agree on what type to use to parse this parameter (integer, character, string, pointer, etc.),
so this becomes a C language programming problem.

<!-- > #### option::通过CTE实现RT-Thread的上下文创建和切换
> 根据上述内容实现相关代码.
> 对于`rt_hw_stack_init()`的实现, 我们已经给出了解决问题的正确方向,
> 但我们并没有指出所有实现相关的细节问题, 剩下的就交给你来分析解决吧,
> 这也是考察你是否已经了解这个过程中的每一处细节. -->
> #### option::Create and switch context of RT-Thread through CTE
> Implement relevant codes according to the above content.
> For the implementation of `rt_hw_stack_init()`, we have given the correct direction to solve the problem,
> But we did not point out all the details related to the implementation, and the rest is left to you to analyze and solve,
> This is also to test whether you have understood every detail of this process.
>
<!-- > 实现后, 尝试在NEMU中运行RT-Thread. 我们已经在移植后的RT-Thread中内置了一些Shell命令,
> 如果你的代码实现正确, 将能看到RT-Thread启动后依次执行这些命令, 最后输出命令提示符`msh >`: -->
> After implementation, try to run RT-Thread in NEMU. We have built some Shell commands into the ported RT-Thread.
> If your code is implemented correctly, you will see that RT-Thread executes these commands in sequence after startup, and finally outputs the command prompt `msh >`:
> ```
> heap: [0x01000000 - 0x09000000]
>
>  \ | /
> - RT -     Thread Operating System
>  / | \     5.0.1 build Oct  2 2023 20:51:10
>  2006 - 2022 Copyright by RT-Thread team
> [I/utest] utest is initialize success.
> [I/utest] total utest testcase num: (0)
> Hello RISC-V!
> msh />help
> RT-Thread shell commands:
> date       - get date and time or set (local timezone) [year month day hour min sec]
>
> ......
>
> msh />utest_list
> [I/utest] Commands list :
> msh />
> ```
<!-- > 由于NEMU目前还不支持通过串口进行交互, 因此我们无法将终端上的输入传送到RT-Thread,
> 所有内置命令运行结束后, RT-Thread将进入空闲状态, 此时退出NEMU即可. -->
> Since NEMU does not currently support interaction via the serial port, we cannot transmit the input on the terminal to RT-Thread.
> After all built-in commands are completed, RT-Thread will enter the idle state, and you can exit NEMU at this time.


<!-- > #### hint::在native上进行上下文切换
> 由于native的AM在创建上下文的时候默认会打开中断, 为了成功运行native创建的内核线程,
> 你还需要在事件处理回调函数中识别出时钟中断事件. 我们会在PA4的最后介绍时钟中断相关的内容,
> 目前识别出时钟中断事件之后什么都不用做, 直接返回相应的上下文结构即可. -->
> #### hint:: Context switch on native
> Since native AM will enable interrupts by default when creating a context, in order to successfully run the kernel thread created by native,
> You also need to identify the clock interrupt event in the event processing callback function. We will introduce the content related to clock interrupts at the end of PA4.
> Currently, after identifying the clock interrupt event, you don't need to do anything, just return the corresponding context structure.


<!-- > #### option::危险的全局变量(4)
> 能否不使用全局变量来实现上下文的切换呢?
>
> 同样地, 我们需要寻找一种不会被多个线程共享的存储空间.
> 不过对于调用`rt_hw_context_switch()`的线程来说, 它的栈正在被使用,
> 往其中写入数据可能会被覆盖, 甚至可能会覆盖已有数据, 使当前线程崩溃.
> `to`的栈虽然当前不使用, 也不会被其他线程共享,
> 但需要考虑如何让`ev_handler()`访问到`to`的栈, 这又回到了我们一开始想要解决的问题. -->
> #### option:: Dangerous global variables (4)
> Can we implement context switching without using global variables?
>
> Similarly, we need to find a storage space that is not shared by multiple threads.
> However, for the thread that calls `rt_hw_context_switch()`, its stack is being used,
> and writing data to it may be overwritten, or even overwrite existing data, causing the current thread to crash.
> Although the stack of `to` is not currently in use and will not be shared by other threads,
> we need to consider how to allow `ev_handler()` to access the stack of `to`, which is back to the problem we wanted to solve at the beginning.
>
<!-- > 除了栈之外, 还有没有其他不会被多个线程共享的存储空间呢?
> 嘿嘿, 其实前文也已经提到过它了, 那就是PCB!
> 因为每个线程对应一个PCB, 而一个线程不会被同时调度多次,
> 所以通过PCB来传递信息也是一个可行的方案.
> 要获取当前线程的PCB, 自然是用`current`指针了. -->
> In addition to the stack, is there any other storage space that is not shared by multiple threads?
> Hey, in fact, it has been mentioned in the previous article, that is PCB!
> Because each thread corresponds to a PCB, and a thread will not be scheduled multiple times at the same time,
> So passing information through PCB is also a feasible solution.
> To get the PCB of the current thread, naturally use the `current` pointer.
>
<!-- > 在RT-Thread中, 可以通过调用`rt_thread_self()`返回当前线程的PCB.
> 阅读RT-Thread中PCB结构体的定义, 我们发现其中有一个成员`user_data`, 它用于存放线程的私有数据,
> 这意味着RT-Thread中调度相关的代码必定不会使用这个成员, 因此它很适合我们用来传递信息.
> 不过为了避免覆盖`user_data`中的已有数据, 我们可以先把它保存在一个临时变量中,
> 在下次切换回当前线程并从`rt_hw_context_switch()`返回之前再恢复它.
> 至于这个临时变量, 当然是使用局部变量了, 毕竟局部变量是在栈上分配的, 完美! -->
> In RT-Thread, you can return the PCB of the current thread by calling `rt_thread_self()`.
> Reading the definition of the PCB structure in RT-Thread, we find that there is a member `user_data`, which is used to store the private data of the thread,
> This means that the scheduling-related code in RT-Thread will definitely not use this member, so it is very suitable for us to use to pass information.
> However, in order to avoid overwriting the existing data in `user_data`, we can save it in a temporary variable first,
> and restore it before switching back to the current thread next time and returning from `rt_hw_context_switch()`.
> As for this temporary variable, of course, a local variable is used. After all, local variables are allocated on the stack, perfect!

<!-- 不过, 目前AM提供的功能不如其他BSP那么丰富,
RT-Thread中一些更复杂的功能还需要底层硬件提供支持, 如网络, 存储等.
因此, 目前我们只能在AM上运行RT-Thread的一个子集, 但这对我们测试和展示来说也足够了. -->
However, the functions provided by AM are not as rich as those of other BSPs. Some more complex functions in RT-Thread also require support from the underlying hardware, such as network, storage, etc. Therefore, we can only run a subset of RT-Thread on AM at present, but this is enough for our testing and demonstration.

### Nanos-lite

<!-- RT-Thread固然是一个完整的OS, 但其内核代码也有约16000行代码,
相比之下Nanos-lite的代码量不到1000行, 更适合大家学习核心原理.
因此, 后续的实验还是会基于Nanos-lite进行. -->
RT-Thread is a complete OS, but its kernel code has about 16,000 lines of code.
In comparison, Nanos-lite has less than 1,000 lines of code, which is more suitable for everyone to learn the core principles.
Therefore, subsequent experiments will still be based on Nanos-lite.

<!-- Nanos-lite上下文切换需要用到的函数和数据结构和`yield-os`非常类似,
只不过由于Nanos-lite的代码规模更大, 它们分散在不同的文件中, 你需要RTFSC找到它们.
此外, Nanos-lite的框架代码已经定义了PCB结构体,
其中还包含其他目前暂不使用的成员, 我们会在将来介绍它们. -->
The functions and data structures needed for Nanos-lite context switching are very similar to those of `yield-os`,
but due to the larger code size of Nanos-lite, they are scattered in different files, and you need RTFSC to find them.
In addition, the framework code of Nanos-lite has defined the PCB structure,
which also contains other members that are not currently used, we will introduce them in the future.

<!-- > #### todo::在Nanos-lite中实现上下文切换
> 实现以下功能:
> * Nanos-lite的`context_kload()`函数(框架代码未给出该函数的原型),
>   它进一步封装了创建内核上下文的过程: 调用`kcontext()`来创建上下文, 并把返回的指针记录到PCB的`cp`中
> * Nanos-lite的`schedule()`函数
> * 在Nanos-lite收到`EVENT_YIELD`事件后, 调用`schedule()`并返回新的上下文
>
> Nanos-lite提供了一个测试函数`hello_fun()`(在`nanos-lite/src/proc.c`中定义),
> 你需要在`init_proc()`中创建两个以`hello_fun`为入口的上下文: -->
> #### todo:: Implement context switching in Nanos-lite
> Implement the following functions:
> * Nanos-lite's `context_kload()` function (the prototype of this function is not given in the framework code),
> It further encapsulates the process of creating kernel context: call `kcontext()` to create the context, and record the returned pointer to the `cp` of the PCB
> * Nanos-lite's `schedule()` function
> * After Nanos-lite receives the `EVENT_YIELD` event, call `schedule()` and return the new context
>
> Nanos-lite provides a test function `hello_fun()` (defined in `nanos-lite/src/proc.c`),
> You need to create two contexts with `hello_fun` as the entry in `init_proc()`:
> ```c
> void init_proc() {
>   context_kload(&pcb[0], hello_fun, ???);
>   context_kload(&pcb[1], hello_fun, ???);
>   switch_boot_pcb();
> }
> ```
<!-- > 其中调用`switch_boot_pcb()`是为了初始化`current`指针.
> 你可以自行约定用何种类型来解析参数`arg`(整数, 字符, 字符串, 指针等皆可),
> 然后修改`hello_fun()`中的输出代码, 来按照你约定的方式解析`arg`.
> 如果你的实现正确, 你将会看到`hello_fun()`会轮流输出不同参数的信息. -->
> The call to `switch_boot_pcb()` is to initialize the `current` pointer.
> You can agree on the type of parameter `arg` to be parsed (integer, character, string, pointer, etc.),
> Then modify the output code in `hello_fun()` to parse `arg` in the way you agreed.
> If your implementation is correct, you will see that `hello_fun()` will output information of different parameters in turn.


<!-- > #### hint::在native上进行上下文切换
> 由于native的AM在创建上下文的时候默认会打开中断, 为了成功运行native创建的内核线程,
> 你还需要在事件处理回调函数中识别出时钟中断事件. 我们会在PA4的最后介绍时钟中断相关的内容,
> 目前识别出时钟中断事件之后什么都不用做, 直接返回相应的上下文结构即可. -->
> #### hint:: Context switch on native
> Since native AM will enable interrupts by default when creating a context, in order to successfully run the kernel thread created by native,
> You also need to identify the clock interrupt event in the event processing callback function. We will introduce the content related to clock interrupts at the end of PA4.
> Currently, after identifying the clock interrupt event, you don't need to do anything, just return the corresponding context structure.

<!-- ## 用户进程 -->
## User Process

<!-- ### 创建用户进程上下文 -->
### Create User Process Context

<!-- 创建用户进程的上下文则需要一些额外的考量.
在PA3的批处理系统中, 我们在`naive_uload()`中直接通过函数调用转移到用户进程的代码,
那时候使用的还是内核区的栈, 万一发生了栈溢出, 确实会损坏操作系统的数据,
不过当时也只有一个用户进程在运行, 我们也就不追究了.
但在多道程序操作系统中, 系统中运行的进程就不止一个了,
如果让用户进程继续使用内核区的栈, 万一发生了栈溢出,
就会影响到其它进程的运行, 这是我们不希望看到的. -->
Creating the context of a user process requires some additional considerations.
In the batch processing system of PA3, we directly transfer the code of the user process through a function call in `naive_uload()`.
At that time, the kernel stack was still used. If a stack overflow occurred, the operating system data would indeed be damaged.
However, there was only one user process running at that time, so we did not pursue it.
But in a multi-programming operating system, there are more than one process running in the system.
If the user process continues to use the kernel stack, if a stack overflow occurs,
it will affect the operation of other processes, which is what we do not want to see.

<!-- > #### comment::如果内核线程发生了栈溢出, 怎么办?
> 如果能检测出来, 最好的方法就是触发kernel panic, 因为这时候内核的数据已经不再可信,
> 如果将一个被破坏的数据写回磁盘, 将会造成无法恢复的毁灭性损坏.
>
> 好消息是, 内核线程的正确性可以由内核开发人员来保证,
> 这至少要比保证那些来路不明的用户进程的正确性要简单多了.
> 而坏消息则是, 大部分的内核bug都是第三方驱动程序导致的:
> 栈溢出算是少见的了, 更多的是use-after-free, double-free, 还有难以捉摸的并发bug.
> 而面对海量的第三方驱动程序, 内核开发人员也难以逐一保证其正确性.
> 如果你想到一个可以提升驱动程序代码质量的方法, 那就是为计算机系统领域作出贡献了. -->
> #### comment::What to do if a kernel thread has a stack overflow?
> If it can be detected, the best way is to trigger a kernel panic, because the kernel data is no longer reliable at this time.
> If a corrupted data is written back to the disk, it will cause irreparable and devastating damage.
>
> The good news is that the correctness of kernel threads can be guaranteed by kernel developers,
> which is at least much simpler than guaranteeing the correctness of unknown user processes.
> The bad news is that most kernel bugs are caused by third-party drivers:
> Stack overflows are rare, and more are use-after-free, double-free, and elusive concurrency bugs.
> Faced with a large number of third-party drivers, it is difficult for kernel developers to guarantee their correctness one by one.
> If you think of a way to improve the quality of driver code, it is to contribute to the field of computer systems.

<!-- 因此, 和内核线程不同, 用户进程的代码, 数据和堆栈都应该位于用户区,
而且需要保证用户进程能且只能访问自己的代码, 数据和堆栈.
为了区别开来, 我们把PCB中的栈称为内核栈, 位于用户区的栈称为用户栈.
于是我们需要一个有别于`kcontext()`的方式来创建用户进程的上下文,
为此AM额外准备了一个API `ucontext()`(在`abstract-machine/am/src/nemu/isa/$ISA/vme.c`中定义),
它的原型是 -->
Therefore, unlike kernel threads, the code, data and stack of user processes should all be located in the user area, and it is necessary to ensure that the user process can and can only access its own code, data and stack. To distinguish them, we call the stack in the PCB the kernel stack, and the stack in the user area the user stack. So we need a way different from `kcontext()` to create the context of the user process. For this purpose, AM has prepared an additional API `ucontext()` (defined in `abstract-machine/am/src/nemu/isa/$ISA/vme.c`), and its prototype is
```c
Context* ucontext(AddrSpace *as, Area kstack, void *entry);
```
<!-- 其中, 参数`as`用于限制用户进程可以访问的内存, 我们在下一阶段才会使用, 目前可以忽略它;
`kstack`是内核栈, 用于分配上下文结构, `entry`则是用户进程的入口.
由于目前我们忽略了`as`参数, 所以`ucontext()`的实现和`kcontext()`几乎一样,
甚至比`kcontext()`更简单: 连参数都不需要传递.
不过你还是需要思考, 对于用户进程来说, 它需要一个什么样的状态来开始执行呢? -->
Among them, the parameter `as` is used to limit the memory that the user process can access. We will use it in the next stage, so you can ignore it for now;
`kstack` is the kernel stack, which is used to allocate the context structure, and `entry` is the entry point of the user process.
Since we have ignored the `as` parameter, the implementation of `ucontext()` is almost the same as `kcontext()`,
even simpler than `kcontext()`: no parameters need to be passed.
But you still need to think about what state the user process needs to start execution.

<!-- 咦, 说好的用户栈呢? 事实上, 用户栈的分配是ISA无关的,
所以用户栈相关的部分就交给Nanos-lite来进行, `ucontext()`无需处理.
目前我们让Nanos-lite把`heap.end`作为用户进程的栈顶,
然后把这个栈顶赋给用户进程的栈指针寄存器就可以了. -->
Hey, where is the user stack? In fact, the allocation of the user stack is independent of ISA,
so the user stack-related parts are handed over to Nanos-lite, and `ucontext()` does not need to be processed.
At present, we let Nanos-lite use `heap.end` as the top of the stack of the user process,
and then assign this top of the stack to the stack pointer register of the user process.

<!-- 哎呀, 栈指针寄存器可是ISA相关的, 在Nanos-lite里面不方便处理.
别着急, 还记得用户进程的那个``_start``吗? 在那里可以进行一些ISA相关的操作.
于是Nanos-lite和Navy作了一项约定: Nanos-lite把栈顶位置设置到GPRx中,
然后由Navy里面的``_start``来把栈顶位置真正设置到栈指针寄存器中. -->
Oops, the stack pointer register is ISA-related, and it is not convenient to handle it in Nanos-lite.
Don't worry, remember the ``_start`` of the user process? Some ISA-related operations can be performed there.
So Nanos-lite and Navy agreed: Nanos-lite sets the top of the stack to GPRx,
and then the ``_start`` in Navy sets the top of the stack to the stack pointer register.

<!-- Nanos-lite可以把上述工作封装到`context_uload()`函数中, 这样我们就可以加载用户进程了.
我们把其中一个`hello_fun()`内核线程替换成仙剑奇侠传: -->
Nanos-lite can encapsulate the above work into the `context_uload()` function so that we can load the user process.
We replace one of the `hello_fun()` kernel threads with the Legend of Sword and Fairy:
```c
context_uload(&pcb[1], "/bin/pal");
```
<!-- 然后我们还需要在`serial_write()`, `events_read()`
和`fb_write()`的开头调用`yield()`, 来模拟设备访问缓慢的情况.
添加之后, 访问设备时就要进行上下文切换, 从而实现多道程序系统的功能. -->
Then we also need to call `yield()` at the beginning of `serial_write()`, `events_read()`
and `fb_write()` to simulate the slow device access situation.
After adding, context switching will be performed when accessing the device, thus realizing the function of a multi-programming system.

<!-- > #### todo::实现多道程序系统
> 根据讲义的上述内容, 实现以下功能, 从而实现多道程序系统:
> * VME的`ucontext()`函数
> * Nanos-lite的`context_uload()`函数(框架代码未给出该函数的原型)
> * 在Navy的``_start``中设置正确的栈指针
>
> 如果你的实现正确, 你将可以一边运行仙剑奇侠传的同时, 一边输出hello信息.
> 需要注意的是, 为了让AM native正确运行, 你也需要在Navy的``_start``中设置正确的栈指针.
>
> 思考一下, 如何验证仙剑奇侠传确实在使用用户栈而不是内核栈? -->
> #### todo:: Implement a multiprogramming system
> According to the above content of the lecture notes, implement the following functions to implement a multiprogramming system:
> * VME's `ucontext()` function
> * Nanos-lite's `context_uload()` function (the prototype of this function is not given in the framework code)
> * Set the correct stack pointer in Navy's ``_start``
>
> If your implementation is correct, you will be able to run Chinese Paladin while outputting hello messages.
> It should be noted that in order for AM native to run correctly, you also need to set the correct stack pointer in Navy's ``_start``.
>
> Think about it, how to verify that Chinese Paladin is indeed using the user stack instead of the kernel stack?


<!-- > #### question::一山不能藏二虎?
> 尝试把`hello_fun()`换成Navy中的`hello`: -->
> #### question::A great man cannot tolerate a rival?
> Try replacing `hello_fun()` with `hello` in Navy:
> ```diff
> -context_kload(&pcb[0], (void *)hello_fun, NULL);
> +context_uload(&pcb[0], "/bin/hello");
>  context_uload(&pcb[1], "/bin/pal");
> ```
<!-- > 你发现了什么问题? 为什么会这样?
> 思考一下, 答案会在下一阶段揭晓! -->
> What problem did you find? Why is it like this?
> Think about it, the answer will be revealed in the next stage!

<!-- ### 用户进程的参数 -->
### Parameters of the user process

<!-- 我们在实现内核线程的时候, 给它传递了一个`arg`参数.
事实上, 用户进程也可以有自己的参数, 那就是你在程序设计课上学习过的`argc`和`argv`了,
还有一个你也许不怎么熟悉的`envp`. `envp`是环境变量指针, 它指向一个字符串数组,
字符串的格式都是形如`xxx=yyy`, 表示有一个名为`xxx`的变量, 它的值为`yyy`.
我们在PA0中通过`init.sh`初始化PA项目的时候, 它会在`.bashrc`文件中定义一些环境变量, 比如`AM_HOME`.
当我们编译FCEUX的时候, `make`程序就会解析`fceux-am/Makefile`中的内容,
当遇到 -->
When we implemented the kernel thread, we passed it an `arg` parameter.
In fact, user processes can also have their own parameters, which are `argc` and `argv` that you learned in the programming class.
There is also `envp` that you may not be familiar with. `envp` is an environment variable pointer, which points to a string array.
The format of the string is like `xxx=yyy`, which means there is a variable named `xxx`, and its value is `yyy`.
When we initialize the PA project through `init.sh` in PA0, it will define some environment variables in the `.bashrc` file, such as `AM_HOME`.
When we compile FCEUX, the `make` program will parse the content in `fceux-am/Makefile`,
When encountering
```make
include $(AM_HOME)/Makefile
```
<!-- 的时候, 就会尝试通过`getenv()`这个库函数在`envp`指向的字符串数组里面寻找是否有形如
`AM_HOME=yyy`的字符串, 如果有, 就返回`yyy`. 如果`AM_HOME`指向了正确的路径,
`make`程序就可以找到`abstract-machine`项目中的`Makefile`文件并包含进来. -->
, it will try to use the library function `getenv()` to find a string in the string array pointed to by `envp`. If there is a string like `AM_HOME=yyy`, it will return `yyy`. If `AM_HOME` points to the correct path, the `make` program can find the `Makefile` file in the `abstract-machine` project and include it.

<!-- 事实上, `main()`函数完整的原型应该是 -->
In fact, the complete prototype of the `main()` function should be
```c
int main(int argc, char *argv[], char *envp[]);
```
<!-- 那么, 当我们在终端里面键入 -->
So, when we type in the terminal
```bash
make ARCH=x86-nemu run
```
<!-- 的时候, `ARCH=x86-nemu`和`run`这两个参数以及环境变量都是怎么传递给`make`程序的`main()`函数的呢? -->
How are the two parameters `ARCH=x86-nemu` and `run` and the environment variables passed to the `main()` function of the `make` program?

<!-- 既然用户进程是操作系统来创建的, 很自然参数和环境变量的传递就需要由操作系统来负责.
最适合存放参数和环境变量的地方就是用户栈了, 因为在首次切换到用户进程的时候,
用户栈上的内容就已经可以被用户进程访问. 于是操作系统在加载用户进程的时候,
还需要负责把`argc/argv/envp`以及相应的字符串放在用户栈中,
并把它们的存放方式和位置作为和用户进程的约定之一,
这样用户进程在``_start``中就可以根据约定访问它们了. -->
Since the user process is created by the operating system, it is natural that the operating system is responsible for the transmission of parameters and environment variables.
The most suitable place to store parameters and environment variables is the user stack, because when switching to the user process for the first time,
the content on the user stack can be accessed by the user process. Therefore, when the operating system loads the user process,
it is also responsible for placing `argc/argv/envp` and the corresponding strings in the user stack,
and making their storage method and location one of the agreements with the user process,
so that the user process can access them according to the agreement in ``_start``.

<!-- 这项约定其实属于ABI的内容, ABI手册有一节Process Initialization的内容,
里面详细约定了操作系统需要为用户进程的初始化提供哪些信息.
不过在我们的Project-N系统里面, 我们只需要一个简化版的Process Initialization就够了:
操作系统将`argc/argv/envp`及其相关内容放置到用户栈上, 然后将GPRx设置为`argc`所在的地址. -->
This convention actually belongs to the content of ABI. The ABI manual has a section on Process Initialization.
It stipulates in detail what information the operating system needs to provide for the initialization of the user process.
But in our Project-N system, we only need a simplified version of Process Initialization:
The operating system places `argc/argv/envp` and its related contents on the user stack, and then sets GPRx to the address where `argc` is located.
```
|               |
+---------------+ <---- ustack.end
|  Unspecified  |
+---------------+
|               | <----------+
|    string     | <--------+ |
|     area      | <------+ | |
|               | <----+ | | |
|               | <--+ | | | |
+---------------+    | | | | |
|  Unspecified  |    | | | | |
+---------------+    | | | | |
|     NULL      |    | | | | |
+---------------+    | | | | |
|    ......     |    | | | | |
+---------------+    | | | | |
|    envp[1]    | ---+ | | | |
+---------------+      | | | |
|    envp[0]    | -----+ | | |
+---------------+        | | |
|     NULL      |        | | |
+---------------+        | | |
| argv[argc-1]  | -------+ | |
+---------------+          | |
|    ......     |          | |
+---------------+          | |
|    argv[1]    | ---------+ |
+---------------+            |
|    argv[0]    | -----------+
+---------------+
|      argc     |
+---------------+ <---- cp->GPRx
|               |
```
<!-- 上图把这些参数分成两部分, 一部分是字符串区域(string area),
另一部分是`argv/envp`这两个字符串指针数组, 数组中的每一个元素是一个字符串指针,
而这些字符串指针都会指向字符串区域中的某个字符串.
此外, 上图中的`Unspecified`表示一段任意长度(也可为0)的间隔,
字符串区域中各个字符串的顺序也不作要求, 只要用户进程可以通过`argv/envp`访问到正确的字符串即可.
这些参数的放置格式与ABI手册中的描述非常类似, 你也可以参考ICS课本第七章的某个图. -->
The above figure divides these parameters into two parts, one part is the string area,
The other part is the two string pointer arrays `argv/envp`. Each element in the array is a string pointer.
These string pointers will point to a certain string in the string area.
In addition, `Unspecified` in the above figure represents an interval of any length (can also be 0),
The order of each string in the string area is not required, as long as the user process can access the correct string through `argv/envp`.
The placement format of these parameters is very similar to the description in the ABI manual. You can also refer to a diagram in Chapter 7 of the ICS textbook.

<!-- > #### comment::阅读ABI手册, 理解计算机系统
> 事实上, ABI手册是ISA, OS, 编译器, 运行时环境, C语言和用户进程的桥梁, 非常值得大家去阅读.
> ICS课本上那些让你摸不着头脑的约定, 大部分也是出自ABI手册.
> Linux上遵守的ABI是System V ABI, 它又分为两部分,
> 一部分是和处理器无关的generic ABI(gABI), 例如ELF格式, 动态连接, 文件系统结构等;
> 另一部分是和处理器相关的processor specific ABI(psABI), 例如调用约定, 操作系统接口, 程序加载等.
> 你至少也应该去看看ABI手册的目录, 翻一下正文部分的图, 这样你就会对ABI手册有一个大致的了解.
> 如果你愿意深入推敲一下"为什么这样约定", 那就是真正的"深入理解计算机系统了". -->
> #### comment::Read the ABI manual and understand the computer system
> In fact, the ABI manual is a bridge between ISA, OS, compiler, runtime environment, C language, and user process. It is worth reading by everyone.
> Most of the conventions in ICS textbooks that make you confused are also from the ABI manual.
> The ABI followed on Linux is System V ABI, which is divided into two parts,
> Part of it is processor-independent generic ABI (gABI), such as ELF format, dynamic connection, file system structure, etc.;
> The other part is the processor specific ABI (psABI) related to the processor, such as calling convention, operating system interface, program loading, etc.
> You should at least read the table of contents of the ABI manual and look through the pictures in the text, so that you will have a general understanding of the ABI manual.
> If you are willing to think deeply about "why it is agreed like this", then you have truly "understood the computer system in depth".

<!-- 根据这一约定, 你还需要修改Navy中``_start``的代码, 把`argc`的地址作为参数传递给`call_main()`.
然后修改`call_main()`的代码, 让它解析出真正的`argc/argv/envp`, 并调用`main()`: -->
According to this convention, you also need to modify the ``_start`` code in Navy to pass the address of `argc` as a parameter to `call_main()`.
Then modify the code of `call_main()` so that it parses the real `argc/argv/envp` and calls `main()`:
```c
void call_main(uintptr_t *args) {
  argc = ???
  argv = ???
  envp = ???
  environ = envp;
  exit(main(argc, argv, envp));
  assert(0);
}
```
<!-- 这样以后, 用户进程就可以接收到属于它的参数了. -->
In this way, the user process can receive the parameters belonging to it.

<!-- > #### todo::给用户进程传递参数
> 这个任务的本质是一个指针相关的编程练习,
> 不过你需要注意编写可移植的代码, 因为`call_main()`是被各种ISA所共享的.
> 然后修改仙剑奇侠传的少量代码, 如果它接收到一个`--skip`参数,
> 就跳过片头商标动画的播放, 否则不跳过. 实现这个功能将有利于加速仙剑奇侠传的测试.
> 商标动画的播放从代码逻辑上距离`main()`函数并不远, 于是就交给你来RTFSC吧.
>
> 不过为了给用户进程传递参数, 你还需要修改`context_uload()`的原型: -->
> #### todo:: Pass parameters to the user process
> The essence of this task is a pointer-related programming exercise,
> But you need to pay attention to writing portable code, because `call_main()` is shared by various ISAs.
> Then modify a small amount of code in Chinese Paladin, if it receives a `--skip` parameter,
> Just skip the playback of the opening trademark animation, otherwise it will not be skipped. Implementing this function will help speed up the testing of Chinese Paladin.
> The playback of trademark animation is not far from the `main()` function in terms of code logic, so I leave it to you to RTFSC.
>
> However, in order to pass parameters to the user process, you also need to modify the prototype of `context_uload()`:
> ```c
> void context_uload(PCB *pcb, const char *filename, char *const argv[], char *const envp[]);
> ```
<!-- > 这样你就可以在`init_proc()`中直接给出用户进程的参数来测试了:
> 在创建仙剑奇侠传用户进程的时候给出`--skip`参数, 你需要观察到仙剑奇侠传确实跳过了商标动画.
> 目前我们的测试程序中不会用到环境变量, 所以不必传递真实的环境变量字符串.
> 至于实参应该写什么, 这又是一个指针相关的问题, 就交给你来解决吧. -->
> This way you can directly give the parameters of the user process in `init_proc()` for testing:
> Give the `--skip` parameter when creating the Chinese Paladin user process, and you need to observe that Legend of Sword and Fairy does indeed skip the trademark animation.
> Currently, environment variables are not used in our test program, so there is no need to pass real environment variable strings.
> As for what the actual parameters should be written, this is another pointer-related issue, so I’ll leave it to you to solve.

<!-- 让操作系统为每一个用户进程手动设定参数是一件不现实的事情,
因为用户进程的参数还是应该由用户来指定的.
于是最好能有一个方法能把用户指定的参数告诉操作系统,
让操作系统来把指定的参数放到新进程的用户栈里面.
这个方法当然就是系统调用`SYS_execve`啦, 如果你去看`man`, 你会发现它的原型是 -->
It is unrealistic for the operating system to manually set parameters for each user process.
Because the parameters of the user process should still be specified by the user.
So it would be best to have a way to tell the operating system the parameters specified by the user.
Let the operating system put the specified parameters into the user stack of the new process.
This method is of course the system call `SYS_execve`. If you look at `man`, you will find that its prototype is
```c
int execve(const char *filename, char *const argv[], char *const envp[]);
```

<!-- > #### question::为什么少了一个const?
> 在`main()`函数中, `argv`和`envp`的类型是`char * []`,
> 而在`execve()`函数中, 它们的类型则是``char *const []``.
> 从这一差异来看, `main()`函数中`argv`和`envp`所指向的字符串是可写的,
> 你知道为什么会这样吗? -->
> #### question::Why is there a const missing?
> In the `main()` function, the types of `argv` and `envp` are `char * []`,
> In the `execve()` function, their types are ``char *const []``.
> Judging from this difference, the strings pointed to by `argv` and `envp` in the `main()` function are writable,
> Do you know why this happens?

<!-- 为了实现带参数的`SYS_execve`, 我们可以在`sys_execve()`中直接调用`context_uload()`.
但我们还需要考虑如下的一些细节, 为了方便描述,
我们假设用户进程A将要通过`SYS_execve`来执行另一个新程序B.
* 如何在A的执行流中创建用户进程B?
* 如何结束A的执行流? -->
In order to implement `SYS_execve` with parameters, we can directly call `context_uload()` in `sys_execve()`.
But we also need to consider the following details, for the convenience of description,
We assume that user process A will execute another new program B through `SYS_execve`.
* How to create user process B in the execution flow of A?
* How to end the execution flow of A?

<!-- 为了回答第一个问题, 我们需要回顾创建用户进程B需要进行哪些操作.
首先是在PCB的内核栈中创建B的上下文结构, 这个过程是安全的, 因为当前进程的内核栈是空的.
接下来就是要在用户栈中放置用户进程B的参数.
但这会涉及到一个新的问题: 我们是否还能复用位于`heap.end`附近的同一个用户栈? -->
To answer the first question, we need to review what is required to create user process B.
The first step is to create the context structure of B in the kernel stack of PCB. This process is safe because the kernel stack of the current process is empty.
The next step is to place the parameters of user process B in the user stack.
But this will involve a new question: Can we still reuse the same user stack located near `heap.end`?

<!-- 为了探究这个问题, 我们需要了解当Nanos-lite尝试通过`SYS_execve`加载B时, A的用户栈里面已经有什么内容.
我们可以从栈底(`heap.end`)到栈顶(栈指针`sp`当前的位置)列出用户栈中的内容:
* Nanos-lite之前为A传递的用户进程参数(`argc/argv/envp`)
* A从``_start``开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的`execve()`
* CTE保存的上下文结构, 这是由于A在`execve()`中执行了系统调用自陷指令导致的
* Nanos-lite从``__am_irq_handle()``开始进行函数调用的栈帧,
  这个栈帧会一直生长, 直到调用了`SYS_execve`的系统调用处理函数 -->
In order to explore this problem, we need to understand what is already in A's user stack when Nanos-lite tries to load B through `SYS_execve`.
We can list the contents of the user stack from the bottom of the stack (`heap.end`) to the top of the stack (the current position of the stack pointer `sp`):
* The user process parameters (`argc/argv/envp`) passed by Nanos-lite for A before
* A stack frame for function calls starting from ``_start``. This stack frame will continue to grow until `execve()` in libos is called.
* The context structure saved by CTE, which is caused by A executing the system call trap instruction in `execve()`
* Nanos-lite starts the stack frame of function call from ``__am_irq_handle()``,
   This stack frame will keep growing until the system call handler of `SYS_execve` is called.

<!-- 通过上述分析, 我们得出一个重要的结论: 在加载B时, Nanos-lite使用的是A的用户栈!
这意味着在A的执行流结束之前, A的用户栈是不能被破坏的.
因此`heap.end`附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈,
来让Nanos-lite把B的参数放置到这个新分配的用户栈里面. -->
Through the above analysis, we come to an important conclusion: when loading B, Nanos-lite uses A's user stack!
This means that before A's execution flow ends, A's user stack cannot be destroyed.
Therefore, the user stack near `heap.end` cannot be reused by B. We should allocate a new memory as B's user stack,
so that Nanos-lite can place B's parameters in this newly allocated user stack.

<!-- 为了实现这一点, 我们可以让`context_uload()`统一通过调用`new_page()`函数来获得用户栈的内存空间.
`new_page()`函数在`nanos-lite/src/mm.c`中定义, 它会通过一个`pf`指针来管理堆区,
用于分配一段大小为`nr_page * 4KB`的连续内存区域, 并返回这段区域的首地址.
我们让`context_uload()`通过`new_page()`来分配32KB的内存作为用户栈,
这对PA中的用户程序来说已经足够使用了.
此外为了简化, 我们在PA中无需实现`free_page()`. -->
To achieve this, we can let `context_uload()` uniformly obtain the memory space of the user stack by calling the `new_page()` function.
The `new_page()` function is defined in `nanos-lite/src/mm.c`, which manages the heap area through a `pf` pointer.
It is used to allocate a continuous memory area of ​​size `nr_page * 4KB` and return the first address of this area.
We let `context_uload()` allocate 32KB of memory as the user stack through `new_page()`,
which is enough for the user program in PA.
In addition, for simplicity, we do not need to implement `free_page()` in PA.

<!-- > #### comment::操作系统的内存管理
> 我们知道klib中的`malloc()`函数也可以进行堆区的管理, 使得AM应用可以方便地进行动态内存申请.
> 但操作系统作为一个特殊的AM应用, 很多时候对动态内存申请却有更严格的要求,
> 例如申请一段起始地址是4KB整数倍的内存区域, `malloc()`通常不能满足这样的要求.
> 因此操作系统一般都会自己来管理堆区, 而不会调用klib中的`malloc()`.
> 在操作系统中管理堆区是MM(Memory Manager)模块的工作, 我们会在后续内容中进一步介绍它. -->
> #### comment:: Memory management of operating system
> We know that the `malloc()` function in klib can also manage the heap area, so that AM applications can easily apply for dynamic memory.
> However, as a special AM application, the operating system often has stricter requirements for dynamic memory application.
> For example, when applying for a memory area with a starting address that is an integer multiple of 4KB, `malloc()` usually cannot meet such requirements.
> Therefore, the operating system generally manages the heap area by itself, and will not call `malloc()` in klib.
> Managing the heap area in the operating system is the work of the MM (Memory Manager) module, which we will introduce in the subsequent content.

<!-- 最后, 为了结束A的执行流, 我们可以在创建B的上下文之后,
通过`switch_boot_pcb()`修改当前的`current`指针, 然后调用`yield()`来强制触发进程调度.
这样以后, A的执行流就不会再被调度, 等到下一次调度的时候, 就可以恢复并执行B了. -->
Finally, in order to end the execution flow of A, we can modify the current `current` pointer through `switch_boot_pcb()` after creating the context of B, and then call `yield()` to force triggering process scheduling. In this way, the execution flow of A will no longer be scheduled, and when it is next scheduled, B can be resumed and executed.

<!-- > #### todo::实现带参数的execve()
> 根据上述讲义内容, 实现带参数的`execve()`. 有一些细节我们并没有完全给出,
> 例如调用`context_uload()`的`pcb`参数应该传入什么内容, 这个问题就交给你来思考吧!
>
> 实现后, 运行以下程序:
> * 测试程序`navy-apps/tests/exec-test`, 它会以参数递增的方式不断地执行自身.
>   不过由于我们没有实现堆区内存的回收, `exec-test`在运行一段时间之后,
>   `new_page()`就会把`0x3000000`/`0x83000000`附近的内存分配出去, 导致用户进程的代码段被覆盖.
>   目前我们无法修复这一问题, 你只需要看到`exec-test`可以正确运行一段时间即可.
> * MENU开机菜单.
> * 完善NTerm的內建Shell, 使得它可以解析输入的参数, 并传递给启动的程序.
>   例如可以在NTerm中键入`pal --skip`来运行仙剑奇侠传并跳过商标动画. -->
> #### todo::Implement execve() with parameters
> According to the above lecture notes, implement `execve()` with parameters. There are some details that we have not fully given,
> For example, what content should be passed to `pcb` parameter when calling `context_uload()`? This question is left to you to think about!
>
> After implementation, run the following program:
> * The test program `navy-apps/tests/exec-test`, which will continuously execute itself with increasing parameters.
> However, since we have not implemented heap area memory recycling, after running `exec-test` for a period of time,
> `new_page()` will allocate memory near `0x3000000`/`0x83000000`, causing the code segment of the user process to be overwritten.
> We can't fix this at the moment, you just need to see that `exec-test` can run correctly for a while.
> * MENU boot menu.
> * Improve NTerm's built-in Shell so that it can parse input parameters and pass them to the started program.
> For example, you can type `pal --skip` in NTerm to run Chinese Paladin and skip the trademark animation.

<!-- ### 运行Busybox -->
### Run Busybox

<!-- 我们已经成功运行了NTerm, 但却没多少Shell工具可以运行.
[Busybox][busybox]正是用来解决这个问题的, 它是一个精简版Shell工具的集合,
包含了大部分常用命令的常用功能.
噢, 你平时在Linux中使用命令行的经历, 很快就可以在你自己构建的计算机系统里面呈现了! -->
We have successfully run NTerm, but there are not many shell tools to run. [Busybox] [busybox] is used to solve this problem. It is a collection of streamlined shell tools, which contains the common functions of most common commands. Oh, your usual experience of using the command line in Linux will soon be presented in the computer system built by yourself!

[busybox]: https://www.busybox.net/about.html

<!-- Navy的框架代码已经准备了Busybox的编译脚本, 首次编译Busybox时脚本会自动克隆项目,
并使用框架代码提供的配置文件. Busybox中包含很多小工具, 你可以通过 -->
Navy's framework code has prepared a compilation script for Busybox. When you compile Busybox for the first time, the script will automatically clone the project and use the configuration file provided by the framework code. Busybox contains many small tools. You can
```
make menuconfig
```
<!-- 来打开一个配置菜单来查看它们(但不要保存对配置的修改).
框架代码提供的配置文件默认只选中了很少的工具,
这是因为大部分工具都需要更多系统调用的支持才能运行, 因此我们无法在Nanos-lite上运行它们. -->
to open a configuration menu to view them (but do not save changes to the configuration).
The configuration file provided by the framework code has only a few tools selected by default.
This is because most tools require more system call support to run, so we cannot run them on Nanos-lite.

<!-- Busybox会把其中的Shell工具链接成一个ELF可执行文件, 而不是像Ubuntu/Debian等发行版中的Shell工具那样,
每个工具都是独立的ELF可执行文件. Busybox的`main()`函数会根据传入的参数来调用相应工具的功能: -->
Busybox links the Shell tools into an ELF executable file, unlike the Shell tools in Ubuntu/Debian and other distributions, where each tool is an independent ELF executable file. Busybox's `main()` function calls the corresponding tool's function based on the passed parameters:
```c
if (strcmp(argv[1], "cat") == 0) return cat_main(argc, argv);
else if (strcmp(argv[1], "ls") == 0) return ls_main(argc, argv);
else if (strcmp(argv[1], "wc") == 0) return wc_main(argc, argv);
// ......
```

<!-- Busybox提供了一个简单的安装脚本, 通过创建一系列的软链接来让用户方便地使用这些小工具: -->
Busybox provides a simple installation script that allows users to easily use these gadgets by creating a series of soft links:
```
$ ls -lh navy-apps/fsimg/bin
total 1.6M
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 base64 -> busybox
-rwxr-xr-x 1 yzh yzh 161K Oct 21 12:11 bird
-rwxr-xr-x 1 yzh yzh 126K Dec  9 12:12 busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 cat -> busybox
-rwxr-xr-x 1 yzh yzh  33K Oct 20 20:43 cpp-test
-rwxr-xr-x 1 yzh yzh  29K Dec  9 12:12 dummy
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 echo -> busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 ed -> busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 false -> busybox
-rwxr-xr-x 1 yzh yzh  33K Dec  9 12:12 hello
-rwxr-xr-x 1 yzh yzh  81K Dec  9 12:12 menu
-rwxr-xr-x 1 yzh yzh  91K Dec  9 12:12 nterm
-rwxr-xr-x 1 yzh yzh 586K Dec  9 12:12 onscripter
-rwxr-xr-x 1 yzh yzh 390K Dec  9 12:12 pal
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 printenv -> busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 sleep -> busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 true -> busybox
```
<!-- 这样以后, 我们键入`cat`命令, 实际上是执行`/bin/busybox`, 来让它执行链接到Busybox的`cat_main()`函数. -->
In this way, when we type the `cat` command, we actually execute `/bin/busybox`, which makes it execute the `cat_main()` function linked to Busybox.

<!-- > #### todo::运行Busybox
> 尝试通过NTerm运行Busybox中的一些简单命令, 比如`cat`和`printenv`等.
> 如果你不清楚这些命令的用法, 可以通过`man`来查阅它们.
> 注意不要让这些命令的输出淹没在`hello_fun()`打印的信息中,
> 为此你可能需要调整`hello_fun()`打印信息的频率. -->
> #### todo::Run Busybox
> Try to run some simple commands in Busybox through NTerm, such as `cat` and `printenv`.
> If you don't know how to use these commands, you can check them through `man`.
> Be careful not to let the output of these commands drown out the information printed by `hello_fun()`.
> For this reason, you may need to adjust the frequency of `hello_fun()` printing information.

<!-- 有一些工具并不是放在`/bin`目录下, 而是放在`/usr/bin`目录下, 例如`wc`.
为了不必输入完整的路径, 我们可以把`/usr/bin`也加入到`PATH`环境变量中.
不同的路径通过`:`进行分隔, 具体格式可以参考在Linux上运行`echo $PATH`命令的结果.
这样以后, 我们就可以通过一个库函数`execvp()`来尝试遍历`PATH`中的所有路径,
直到找到一个存在的可执行文件为止, 找到之后就会调用`SYS_execve`.
你可以通过阅读`navy-apps/libs/libc/src/posix/execvp.c`来了解这一功能是如何实现的. -->
Some tools are not placed in the `/bin` directory, but in the `/usr/bin` directory, such as `wc`.
In order to avoid entering the full path, we can also add `/usr/bin` to the `PATH` environment variable.
Different paths are separated by `:`. The specific format can refer to the result of running the `echo $PATH` command on Linux.
In this way, we can use a library function `execvp()` to try to traverse all paths in `PATH`,
until an existing executable file is found, and then `SYS_execve` will be called.
You can read `navy-apps/libs/libc/src/posix/execvp.c` to understand how this function is implemented.

<!-- 不过为了遍历`PATH`中的路径, `execvp()`可能会尝试执行一个不存在的用户程序, 例如`/bin/wc`.
因此Nanos-lite在处理`SYS_execve`系统调用的时候就需要检查将要执行的程序是否存在,
如果不存在, 就需要返回一个错误码.
我们可以通过`fs_open()`来进行检查, 如果需要打开的文件不存在,
就返回一个错误的值, 此时`SYS_execve`返回`-2`.
另一方面, libos中的`execve()`还需要检查系统调用的返回值:
如果系统调用的返回值小于0, 则通常表示系统调用失败, 此时需要将系统调用返回值取负,
作为失败原因设置到一个全局的外部变量`errno`中, 然后返回`-1`. -->
However, in order to traverse the paths in `PATH`, `execvp()` may try to execute a non-existent user program, such as `/bin/wc`.
Therefore, when Nanos-lite processes the `SYS_execve` system call, it needs to check whether the program to be executed exists.
If it does not exist, it needs to return an error code.
We can check it through `fs_open()`. If the file to be opened does not exist,
it returns an error value, and `SYS_execve` returns `-2`.
On the other hand, `execve()` in libos also needs to check the return value of the system call:
If the return value of the system call is less than 0, it usually means that the system call failed. At this time, the return value of the system call needs to be negative,
set as the reason for failure to a global external variable `errno`, and then return `-1`.

<!-- > #### comment::-2和errno
> `errno`是C标准定义的, 运行时环境中的一个全局变量,
> 用于存放最近一次失败的系统调用或库函数调用的错误码.
> 你可以通过运行`errno -l`命令(需要通过`apt-get`安装`moreutils`包)
> 来查看所有的错误码及其含义, 你应该能看到错误码`2`是你比较熟悉的一种错误.
> 关于`errno`全局变量的更多信息, 可以参考`man 3 errno`. -->
> #### comment::-2 and errno
> `errno` is a global variable defined by the C standard and in the runtime environment,
> which is used to store the error code of the most recent failed system call or library function call.
> You can view all error codes and their meanings by running the command `errno -l` (you need to install the `moreutils` package through `apt-get`).
> You should see that error code `2` is an error that you are familiar with.
> For more information about the `errno` global variable, refer to `man 3 errno`.


<!-- > #### todo::运行Busybox(2)
> 实现上述内容, 让`execvp()`支持`PATH`的遍历.
> 然后尝试通过NTerm运行`wc`等位于`/usr/bin`目录下的命令,
> 例如`wc /share/games/bird/atlas.txt`.
> 你可以通过在Linux上运行相应命令来查看结果是否正确.
> 此外, 你可以通过阅读`execvp()`的代码来帮助你判断返回值的设置是否正确. -->
> #### todo::Run Busybox(2)
> Implement the above content and let `execvp()` support `PATH` traversal.
> Then try to run `wc` and other commands in the `/usr/bin` directory through NTerm,
> For example, `wc /share/games/bird/atlas.txt`.
> You can check whether the result is correct by running the corresponding command on Linux.
> In addition, you can read the code of `execvp()` to help you judge whether the return value is set correctly.

<!-- 虽然目前我们只能在Nanos-lite上运行很少部分的Busybox工具,
但你基本上在自己构建的计算机系统里面呈现了与你平时使用Linux命令行工具非常相似的一幕.
我们把这件事放到Project-N的系统栈里面, 就是为了能够让你明白,
你平时键入命令的时候计算机系统的各个抽象层都做了些什么:
* 终端如何读取用户的按键?
* Shell如何进行命令的解析?
* 库函数如何根据命令解析出的字符串搜索到可执行文件?
* 操作系统如何加载执行一个可执行文件?
* ...... -->
Although we can only run a few Busybox tools on Nanos-lite at present, you basically present a scene very similar to your usual use of Linux command line tools in the computer system you built. We put this into the system stack of Project-N to let you understand what the various abstract layers of the computer system do when you usually type commands: 
* How does the terminal read the user's keystrokes? 
* How does the Shell parse the command? 
* How does the library function search for the executable file based on the string parsed by the command? 
* How does the operating system load and execute an executable file? 
* ......

<!-- 虽然Project-N和真实的Linux系统还有很大的差异,
但独立完成PA已经可以很大程度上帮助你消除对"程序如何在计算机上运行"的神秘感. -->
Although there are still huge differences between Project-N and the real Linux system, completing PA independently can help you eliminate the mystery of "how programs run on computers" to a great extent.

<!-- > #### hint::温馨提示
> PA4阶段1到此结束. -->
> #### hint:: Friendly reminder
> PA4 Phase 1 ends here.