<!-- ## 简易文件系统 -->
## Simple file system

<!-- 要实现一个完整的批处理系统, 我们还需要向系统提供多个程序.
我们之前把程序以文件的形式存放在ramdisk之中,
但如果程序的数量增加之后, 我们就要知道哪个程序在ramdisk的什么位置.
我们的ramdisk已经提供了读写接口, 使得我们可以很方便地访问某一个位置的内容,
这对Nanos-lite来说貌似没什么困难的地方;
另一方面, 用户程序也需要处理数据, 它们处理的数据也可能会组织成文件,
那么对用户程序来说, 它怎么知道文件位于ramdisk的哪一个位置呢?
更何况文件会动态地增删, 用户程序并不知情.
这说明, 把ramdisk的读写接口直接提供给用户程序来使用是不可行的.
操作系统还需要在存储介质的驱动程序之上为用户程序提供一种更高级的抽象, 那就是文件. -->
To implement a complete batch processing system, we need to provide multiple programs to the system.
Previously, we stored programs as files on ramdisk,
but if the number of programs increases, we need to know the location of each program on the ramdisk.
Our ramdisk has already provided read and write interfaces, making it convenient to access content at any location,
which seems not difficult for Nanos-lite;
On the other hand, user programs also need to process data, which may also be organized into files,
so for user programs, how do they know the location of files on the ramdisk?
Moreover, files are dynamically added and deleted, and user programs are not aware of this.
This indicates that it is not feasible to directly provide the ramdisk's read and write interface for use by user programs.
The operating system also needs to provide a higher level of abstraction for user programs on top of the storage medium's driver, which is the file.

<!-- 文件的本质就是字节序列, 另外还由一些额外的属性构成.
在这里, 我们先讨论普通意义上的文件.
这样, 那些额外的属性就维护了文件到ramdisk存储位置的映射.
为了管理这些映射, 同时向上层提供文件操作的接口, 我们需要在Nanos-lite中实现一个文件系统. -->
The essence of a file is a sequence of bytes, along with some additional attributes.
Here, we first discuss files in the ordinary sense.
Thus, those additional attributes maintain the mapping of files to storage locations on the ramdisk.
To manage these mappings and provide an interface for file operations to the upper layer, we need to implement a file system in Nanos-lite.

<!-- 不要被"文件系统"四个字吓到了, 我们对文件系统的需求并不是那么复杂,
因此我们可以定义一个简易文件系统sfs(Simple File System):
* 每个文件的大小是固定的
* 写文件时不允许超过原有文件的大小
* 文件的数量是固定的, 不能创建新文件
* 没有目录

既然文件的数量和大小都是固定的, 我们自然可以把每一个文件分别固定在ramdisk中的某一个位置.
这些简化的特性大大降低了文件系统的实现难度.
当然, 真实的文件系统远远比sfs复杂. -->
Do not be intimidated by the term "file system"; our needs for a file system are not that complex,
thus we can define a simple file system, sfs (Simple File System):
* The size of each file is fixed
* Writing to a file is not allowed to exceed the original size of the file
* The number of files is fixed, and new files cannot be created
* There are no directories

Since the number and size of the files are fixed, we can naturally fix each file at a specific location on the ramdisk.
These simplified features greatly reduce the complexity of implementing a file system.
Of course, real file systems are much more complex than sfs.

<!-- 我们约定文件从ramdisk的最开始一个挨着一个地存放:
```
0
+-------------+---------+----------+-----------+--
|    file0    |  file1  |  ......  |   filen   |
+-------------+---------+----------+-----------+--
 \           / \       /            \         /
  +  size0  +   +size1+              + sizen +
```
为了记录ramdisk中各个文件的名字和大小, 我们还需要一张"文件记录表". -->
We agree that files are stored one after another from the very beginning of the ramdisk:
```
0
+-------------+---------+----------+-----------+--
|    file0    |  file1  |  ......  |   filen   |
+-------------+---------+----------+-----------+--
 \           / \       /            \         /
  +  size0  +   +size1+              + sizen +
```
To record the names and sizes of various files in the ramdisk, we also need a "file record table".

<!-- Nanos-lite的Makefile已经提供了维护这些信息的脚本, 先对`nanos-lite/Makefile`作如下修改:
```diff
--- nanos-lite/Makefile
+++ nanos-lite/Makefile
@@ -1,2 +1,2 @@
-#HAS_NAVY = 1
+HAS_NAVY = 1
 RAMDISK_FILE = build/ramdisk.img
```
然后运行`make ARCH=$ISA-nemu update`就会自动编译Navy中的程序,
并把`navy-apps/fsimg/`目录下的所有内容整合成ramdisk镜像`navy-apps/build/ramdisk.img`,
同时生成这个ramdisk镜像的文件记录表`navy-apps/build/ramdisk.h`,
Nanos-lite的`Makefile`会通过软连接把它们链接到项目中. -->
Nanos-lite's Makefile has already provided a script to maintain this information, first modify `nanos-lite/Makefile` as follows:
```diff
--- nanos-lite/Makefile
+++ nanos-lite/Makefile
@@ -1,2 +1,2 @@
-#HAS_NAVY = 1
+HAS_NAVY = 1
 RAMDISK_FILE = build/ramdisk.img
```
Then running `make ARCH=$ISA-nemu update` will automatically compile the programs in Navy,
and integrate all the contents under the `navy-apps/fsimg/` directory into the ramdisk image `navy-apps/build/ramdisk.img`,
while generating the file record table `navy-apps/build/ramdisk.h` for this ramdisk image,
Nanos-lite's `Makefile` will link them to the project through a soft link.

<!-- > #### hint::记得更新镜像文件
> 如果你修改了Navy中的内容, 请记得通过上述命令来更新镜像文件. -->
> #### hint::Remember to update the image file
> If you have modified the content in Navy, please remember to update the image file through the above command.

<!-- "文件记录表"其实是一个数组, 数组的每个元素都是一个结构体:
```c
typedef struct {
  char *name;         // 文件名
  size_t size;        // 文件大小
  size_t disk_offset;  // 文件在ramdisk中的偏移
} Finfo;
```
在sfs中, 这三项信息都是固定不变的. 其中的文件名和我们平常使用的习惯不太一样:
由于sfs没有目录, 我们把目录分隔符`/`也认为是文件名的一部分,
例如`/bin/hello`是一个完整的文件名.
这种做法其实也隐含了目录的层次结构,
对于文件数量不多的情况, 这种做法既简单又奏效. -->
The "file record table" is actually an array, each element of which is a structure:
```c
typedef struct {
  char *name;         // File name
  size_t size;        // File size
  size_t disk_offset;  // File offset in ramdisk
} Finfo;
```
In sfs, these three pieces of information are fixed and unchangeable. The file names are a bit different from our usual habits:
Since sfs has no directories, we consider the directory separator `/` as part of the file name,
for example, `/bin/hello` is a complete file name.
This approach also implies a hierarchical structure of directories,
for a small number of files, this approach is both simple and effective.

<!-- 有了这些信息, 就已经可以实现最基本的文件读写操作了:
```c
size_t read(const char *filename, void *buf, size_t len);
size_t write(const char *filename, const void *buf, size_t len);
```
但在真实的操作系统中, 这种直接用文件名来作为读写操作参数的做法却有所缺陷.
例如, 我们在用`less`工具浏览文件的时候:
```bash
cat file | less
```
`cat`工具希望把文件内容写到`less`工具的标准输入中,
但我们却无法用文件名来标识`less`工具的标准输入!
实际上, 操作系统中确实存在不少"没有名字"的文件.
为了统一管理它们, 我们希望通过一个编号来表示文件, 这个编号就是文件描述符(file descriptor).
一个文件描述符对应一个正在打开的文件, 由操作系统来维护文件描述符到具体文件的映射.
于是我们很自然地通过`open()`系统调用来打开一个文件, 并返回相应的文件描述符 -->
With this information, the most basic file read and write operations can already be implemented:
```c
size_t read(const char *filename, void *buf, size_t len);
size_t write(const char *filename, const void *buf, size_t len);
```
But in real operating systems, this practice of directly using file names as parameters for read and write operations has its flaws.
For example, when we use the `less` tool to browse files:
```bash
cat file | less
```
The `cat` tool wants to write the file content to the standard input of the `less` tool,
but we cannot use a file name to identify the standard input of the `less` tool!
In fact, there are indeed many "nameless" files in the operating system.
To manage them uniformly, we wish to represent a file by a number, which is the file descriptor.
A file descriptor corresponds to an open file, with the operating system maintaining the mapping from file descriptors to specific files.
Thus, we naturally use the `open()` system call to open a file and return the corresponding file descriptor.

<!-- 在Nanos-lite中, 由于sfs的文件数目是固定的,
我们可以简单地把文件记录表的下标作为相应文件的文件描述符返回给用户程序.
在这以后, 所有文件操作都通过文件描述符来标识文件:
```c
size_t read(int fd, void *buf, size_t len);
size_t write(int fd, const void *buf, size_t len);
int close(int fd);
```
另外, 我们也不希望每次读写操作都需要从头开始.
于是我们需要为每一个已经打开的文件引入偏移量属性`open_offset`, 来记录目前文件操作的位置.
每次对文件读写了多少个字节, 偏移量就前进多少. -->
In Nanos-lite, since the number of files in sfs is fixed,
we can simply use the index of the file record table as the file descriptor for the corresponding file and return it to the user program.
After this, all file operations are identified through file descriptors:
```c
size_t read(int fd, void *buf, size_t len);
size_t write(int fd, const void *buf, size_t len);
int close(int fd);
```
Additionally, we do not want every read and write operation to start from the beginning.
Therefore, we need to introduce an `open_offset` attribute for each open file to record the current position of file operations.
Each time a certain number of bytes is read or written to a file, the offset advances by that amount.

<!-- > #### comment::文件偏移量和用户程序
> 事实上在真正的操作系统中, 把偏移量放在文件记录表中维护会导致用户程序无法实现某些功能.
> 但解释这个问题需要理解一些超出课程范围的知识, 我们在此就不展开叙述了.
> 你可以在学习操作系统课程的时候再来思考这个问题.
>
> 由于Nanos-lite是一个精简版的操作系统, 上述问题暂时不会出现,
> 为了简化实现, 我们还是把偏移量放在文件记录表中进行维护. -->
> #### comment::File Offset and User Programs
> In real operating systems, maintaining the offset within the file record table can prevent user programs from implementing certain functionalities.
> However, explaining this issue requires understanding some knowledge beyond the scope of this course, so we will not elaborate here.
> You can think about this issue when you study operating systems courses.
>
> Since Nanos-lite is a simplified operating system, the above problem will not occur temporarily,
> To simplify the implementation, we still maintain the offset in the file record table.

<!-- 偏移量可以通过`lseek()`系统调用来调整, 从而可以对文件中的任意位置进行读写:
```c
size_t lseek(int fd, size_t offset, int whence);
``` -->
Offsets can be adjusted through the `lseek()` system call, allowing for reading and writing at any position within the file:
```c
size_t lseek(int fd, size_t offset, int whence);
```

<!-- 为了方便用户程序进行标准输入输出, 操作系统准备了三个默认的文件描述符:
```c
#define FD_STDIN 0
#define FD_STDOUT 1
#define FD_STDERR 2
```
它们分别对应标准输入`stdin`, 标准输出`stdout`和标准错误`stderr`.
我们经常使用的printf, 最终会调用`write(FD_STDOUT, buf, len)`进行输出;
而scanf将会通过调用`read(FD_STDIN, buf, len)`进行读入. -->
To facilitate standard input and output for user programs, the operating system has prepared three default file descriptors:
```c
#define FD_STDIN 0
#define FD_STDOUT 1
#define FD_STDERR 2
```
They correspond to standard input `stdin`, standard output `stdout`, and standard error `stderr`.
The frequently used printf ultimately calls `write(FD_STDOUT, buf, len)` for output;
while scanf will read input by calling `read(FD_STDIN, buf, len)`.

<!-- `nanos-lite/src/fs.c`中定义的`file_table`会包含`nanos-lite/src/files.h`,
其中前面还有3个特殊的文件: `stdin`, `stdout`和`stderr`的占位表项,
它们只是为了保证sfs和约定的标准输入输出的文件描述符保持一致,
例如根据约定`stdout`的文件描述符是`1`, 而我们添加了三个占位表项之后,
文件记录表中的`1`号下标也就不会分配给其它的普通文件了. -->
The `file_table` defined in `nanos-lite/src/fs.c` will include `nanos-lite/src/files.h`,
which also contains placeholders for three special files: `stdin`, `stdout`, and `stderr`,
These are just to ensure that the sfs and the agreed standard input and output file descriptors remain consistent,
for example, according to the agreement, the file descriptor for `stdout` is `1`, and after we add three placeholder entries,
the index `1` in the file record table will not be allocated to other ordinary files.

<!-- 根据以上信息, 我们就可以在文件系统中实现以下的文件操作了:
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
这些文件操作实际上是相应的系统调用在内核中的实现.
你可以通过 `man` 查阅它们的功能, 例如
```
man 2 open
```
其中`2`表示查阅和系统调用相关的manual page. 实现这些文件操作的时候注意以下几点:
* 由于sfs中每一个文件都是固定的, 不会产生新文件,
因此"`fs_open()`没有找到`pathname`所指示的文件"属于异常情况, 你需要使用assertion终止程序运行.
* 为了简化实现, 我们允许所有用户程序都可以对所有已存在的文件进行读写,
这样以后, 我们在实现`fs_open()`的时候就可以忽略`flags`和`mode`了.
* 使用`ramdisk_read()`和`ramdisk_write()`来进行文件的真正读写.
* 由于文件的大小是固定的, 在实现`fs_read()`,
`fs_write()`和`fs_lseek()`的时候, 注意偏移量不要越过文件的边界.
* 除了写入`stdout`和`stderr`之外(用`putch()`输出到串口),
其余对于`stdin`, `stdout`和`stderr`这三个特殊文件的操作可以直接忽略.
* 由于sfs没有维护文件打开的状态, `fs_close()`可以直接返回`0`, 表示总是关闭成功. -->
Based on the above information, we can implement the following file operations in the file system:
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
These file operations are actually implementations of the corresponding system calls in the kernel.
You can consult their functions through `man`, for example
```
man 2 open
```
where `2` indicates consulting the manual page related to system calls. When implementing these file operations, note the following points:
* Since every file in sfs is fixed and does not generate new files,
thus "`fs_open()` not finding the file indicated by `pathname`" is an exceptional situation, you need to use assertion to terminate the program.
* To simplify implementation, we allow all user programs to read and write all existing files,
thus later, we can ignore `flags` and `mode` when implementing `fs_open()`.
* Use `ramdisk_read()` and `ramdisk_write()` for actual file read and write operations.
* Since the size of the files is fixed, when implementing `fs_read()`,
`fs_write()`, and `fs_lseek()`, be careful not to exceed the file boundaries.
* Apart from writing to `stdout` and `stderr` (output to the serial port using `putch()`),
operations on the three special files `stdin`, `stdout`, and `stderr` can be directly ignored.
* Since sfs does not maintain the state of file opening, `fs_close()` can directly return `0`, indicating always successful closure.

<!-- 最后你还需要在Nanos-lite和Navy的libos中添加相应的系统调用, 来调用相应的文件操作. -->
Finally, you also need to add the corresponding system calls in Nanos-lite and Navy's libos to invoke the respective file operations.

<!-- > #### todo::让loader使用文件
> 我们之前是让loader来直接调用`ramdisk_read()`来加载用户程序.
> ramdisk中的文件数量增加之后, 这种方式就不合适了,
> 我们首先需要让loader享受到文件系统的便利.
>
> 你需要先实现`fs_open()`, `fs_read()`和`fs_close()`,
> 这样就可以在loader中使用文件名来指定加载的程序了, 例如"/bin/hello".
>
> 实现之后, 以后更换用户程序只需要修改传入`naive_uload()`函数的文件名即可. -->
> #### todo::Let the loader use files
> Previously, we had the loader directly call `ramdisk_read()` to load user programs.
> After the number of files in the ramdisk increases, this method becomes inappropriate,
> we first need to let the loader enjoy the convenience of the file system.
>
> You need to first implement `fs_open()`, `fs_read()`, and `fs_close()`,
> so that you can use filenames in the loader to specify the program to load, such as "/bin/hello".
>
> After implementation, changing user programs later will only require modifying the filename passed to the `naive_uload()` function.

<!-- > #### todo::实现完整的文件系统
> 实现`fs_write()`和`fs_lseek()`, 然后运行测试程序`navy-apps/tests/file-test`.
> 为了编译它, 你需要把它加到`navy-apps/Makefile`的`TESTS`变量中,
> 这样它最终就会被包含在ramdisk镜像中.
> 这个测试程序用于进行一些简单的文件读写和定位操作.
> 如果你的实现正确, 你将会看到程序输出`PASS!!!`的信息. -->
> #### todo::Implement a complete file system
> Implement `fs_write()` and `fs_lseek()`, then run the test program `navy-apps/tests/file-test`.
> To compile it, you need to add it to the `TESTS` variable in `navy-apps/Makefile`,
> so that it will ultimately be included in the ramdisk image.
> This test program is used for some simple file read, write, and positioning operations.
> If your implementation is correct, you will see the program output `PASS!!!`.

<!-- > #### hint::记得更新应用程序列表
> 如果你希望在镜像中添加一个应用程序, 请记得将它加入到上述Makefile文件的应用程序列表中. -->
> #### hint::Remember to update the application list
> If you want to add an application to the image, remember to add it to the application list in the above Makefile file.

<!-- > #### todo::支持sfs的strace
> 由于sfs的特性, 打开同一个文件总是会返回相同的文件描述符.
> 这意味着, 我们可以把strace中的文件描述符直接翻译成文件名, 得到可读性更好的trace信息.
> 尝试实现这一功能, 它可以为你将来使用strace提供一些便利. -->
> #### todo::Support sfs's strace
> Due to the characteristics of sfs, opening the same file always returns the same file descriptor.
> This means that we can directly translate the file descriptors in strace into filenames, obtaining more readable trace information.
> Try to implement this feature, it can provide some convenience for your future use of strace.

<!-- ## 一切皆文件 -->
## Everything is file

<!-- AM中的IOE向我们展现了程序进行输入输出的需求.
那么在Nanos-lite上, 如果用户程序想访问设备, 要怎么办呢?
一种最直接的方式, 就是让操作系统为每个设备单独提供一个系统调用,
用户程序通过这些系统调用, 就可以直接使用相应的功能了.
然而这种做法却存在不少问题:
* 首先, 设备的类型五花八门, 其功能更是数不胜数,
要为它们分别实现系统调用来给用户程序提供接口, 本身就已经缺乏可行性了;
* 此外, 由于设备的功能差别较大, 若提供的接口不能统一, 程序和设备之间的交互就会变得困难.
  所以我们需要有一种方式对设备的功能进行抽象, 向用户程序提供统一的接口. -->
IOE in AM shows us the need for programs to perform input and output.
So, on Nanos-lite, how should user programs access devices?
One direct method is for the operating system to provide a separate system call for each device,
allowing user programs to directly use the corresponding functionalities.
However, this approach has several problems:
* First, the types of devices are varied and their functionalities are numerous,
making it impractical to implement separate system calls for each to provide interfaces to user programs;
* Moreover, due to the significant differences in device functionalities, if the provided interfaces are not unified, the interaction between programs and devices becomes difficult.
Thus, we need a way to abstract the functionalities of devices to provide a unified interface to user programs.

<!-- 我们之前提到, 文件的本质就是字节序列.
事实上, 计算机系统中到处都是字节序列(如果只是无序的字节集合, 计算机要如何处理?),
我们可以轻松地举出很多例子:
* 内存是以字节编址的, 天然就是一个字节序列, 因而我们之前使用的ramdisk作为字节序列也更加显而易见了
* 管道(shell命令中的`|`)是一种先进先出的字节序列, 本质上它是内存中的一个队列缓冲区
* 磁盘也可以看成一个字节序列:
我们可以为磁盘上的每一个字节进行编号, 例如第x柱面第y磁头第z扇区中的第n字节,
把磁盘上的所有字节按照编号的大小进行排列, 便得到了一个字节序列
* socket(网络套接字)也是一种字节序列, 它有一个缓冲区, 负责存放接收到的网络数据包,
上层应用将socket中的内容看做是字节序列, 并通过一些特殊的文件操作来处理它们.
我们在PA2中介绍了DiffTest, 如果你RTFSC, 就会发现其中的`qemu-diff`就是通过socket与QEMU进行通信的,
而操作socket的方式就是`fgetc()`和`fputc()`
* 操作系统的一些信息可以以字节序列的方式暴露给用户, 例如CPU的配置信息
* 操作系统提供的一些特殊的功能, 如随机数生成器, 也可以看成一个无穷长的字节序列
* 甚至一些非存储类型的硬件也可以看成是字节序列:
我们在键盘上按顺序敲入按键的编码形成了一个字节序列,
显示器上每一个像素的内容按照其顺序也可以看做是字节序列... -->
We previously mentioned that the essence of a file is a sequence of bytes.
In fact, computer systems are filled with sequences of bytes (how would a computer handle a mere unordered collection of bytes?),
and we can easily list many examples:
* Memory is byte-addressed, naturally forming a byte sequence, making our previously used ramdisk as a byte sequence even more apparent
* A pipe (the `|` in shell commands) is a FIFO byte sequence, essentially a queue buffer in memory
* A disk can also be seen as a byte sequence:
We can number each byte on the disk, for example, the nth byte in the xth cylinder, yth head, zth sector,
arranging all the bytes on the disk by number size, we get a byte sequence
* A socket (network socket) is also a byte sequence, it has a buffer responsible for storing received network packets,
upper-layer applications view the contents of the socket as a byte sequence and handle them through some special file operations.
In PA2, we introduced DiffTest, if you RTFSC, you will find that `qemu-diff` communicates with QEMU through a socket,
and the way to operate a socket is `fgetc()` and `fputc()`
* Some information of the operating system can be exposed to users in the form of byte sequences, such as CPU configuration information
* Some special functions provided by the operating system, such as random number generators, can also be seen as an infinitely long byte sequence
* Even some non-storage type hardware can be seen as byte sequences:
The sequence of key codes we type on the keyboard forms a byte sequence,
the content of each pixel on the display can also be seen as a byte sequence...

<!-- 既然文件就是字节序列, 那很自然地, 上面这些五花八门的字节序列应该都可以看成文件.
Unix就是这样做的, 因此有"一切皆文件"(Everything is a file)的说法.
这种做法最直观的好处就是为不同的事物提供了统一的接口:
我们可以使用文件的接口来操作计算机上的一切, 而不必对它们进行详细的区分: 例如
`navy-apps/Makefile`的`ramdisk`规则通过管道把各个shell工具的输入输出连起来, 生成文件记录表
```bash
wc -c $(FSIMG_FILES) | grep -v 'total$$' | sed -e 's+ ./fsimg+ +' |
  awk -v sum=0 '{print "\x7b\x22" $$2 "\x22\x2c " $$1 "\x2c " sum "\x7d\x2c";sum += $$1}' >> $(RAMDISK_H)
```
以十六进制的方式查看磁盘上的内容
```bash
head -c 512 /dev/sda | hd
```
查看CPU是否有Spectre漏洞
```bash
cat /proc/cpuinfo | grep 'spectre'
```
甚至我们在PA2中提供的"小星星"示例音频, 也是通过简单的文件操作暴力拼接而成的
```bash
cat Do.ogg Do.ogg So.ogg So.ogg La.ogg La.ogg So.ogg > little-star.ogg
```
而
```c
#include "/dev/urandom"
```
则会将urandom设备中的内容包含到源文件中: 由于urandom设备是一个长度无穷的字节序列,
提交一个包含上述内容的程序源文件将会令一些检测功能不强的Online Judge平台直接崩溃.

"一切皆文件"的抽象使得我们可以通过标准工具很容易完成一些在Windows下不易完成的工作,
这其实体现了Unix哲学的部分内容: 每个程序采用文本文件作为输入输出, 这样可以使程序之间易于合作.
GNU/Linux继承自Unix, 也自然继承了这种优秀的特性.
为了向用户程序提供统一的抽象, Nanos-lite也尝试将IOE抽象成文件. -->
Since a file is a byte sequence, naturally, all the varied byte sequences mentioned above can be considered files.
Unix operates this way, hence the saying "Everything is a file."
This approach's most intuitive benefit is providing a unified interface for different things:
We can use the file interface to operate everything on the computer without having to distinguish them in detail, for example,
the `ramdisk` rule in `navy-apps/Makefile` connects the input and output of various shell tools through pipes to generate a file record table
```bash
wc -c $(FSIMG_FILES) | grep -v 'total$$' | sed -e 's+ ./fsimg+ +' |
  awk -v sum=0 '{print "\x7b\x22" $$2 "\x22\x2c " $$1 "\x2c " sum "\x7d\x2c";sum += $$1}' >> $(RAMDISK_H)
```
View the contents of a disk in hexadecimal
```bash
head -c 512 /dev/sda | hd
```
Check if the CPU has the Spectre vulnerability
```bash
cat /proc/cpuinfo | grep 'spectre'
```
Even the "Little Star" sample audio we provided in PA2 was created through simple file operations by brute force concatenation
```bash
cat Do.ogg Do.ogg So.ogg So.ogg La.ogg La.ogg So.ogg > little-star.ogg
```
and
```c
#include "/dev/urandom"
```
will include the contents of the urandom device in the source file: since the urandom device is an infinitely long byte sequence,
submitting a program source file containing the above content will cause some Online Judge platforms with weak detection features to crash directly.

The abstraction of "everything is a file" allows us to easily accomplish some tasks on Windows that are difficult to complete,
reflecting part of the Unix philosophy: each program uses text files for input and output, making it easy for programs to cooperate.
GNU/Linux, inheriting from Unix, naturally carries on this excellent feature.
To provide a unified abstraction to user programs, Nanos-lite also attempts to abstract IOE as files.

### 虚拟文件系统
### Virtual File System

<!-- 为了实现一切皆文件的思想, 我们之前实现的文件操作就需要进行扩展了:
我们不仅需要对普通文件进行读写, 还需要支持各种"特殊文件"的操作.
至于扩展的方式, 你是再熟悉不过的了, 那就是抽象!

我们对之前实现的文件操作API的语义进行扩展, 让它们可以支持任意文件(包括"特殊文件")的操作:
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
这组扩展语义之后的API有一个酷炫的名字, 叫[VFS(虚拟文件系统)][vfs].
既然有虚拟文件系统, 那相应地也应该有"真实文件系统",
这里所谓的真实文件系统, 其实是指具体如何操作某一类文件.
比如在Nanos-lite上, 普通文件通过ramdisk的API进行操作;
在真实的操作系统上, 真实文件系统的种类更是数不胜数:
比如熟悉Windows的你应该知道管理普通文件的NTFS, 目前在GNU/Linux上比较流行的则是EXT4;
至于特殊文件的种类就更多了, 于是相应地有`procfs`, `tmpfs`, `devfs`, `sysfs`, `initramfs`...
这些不同的真实文件系统, 它们都分别实现了这些文件的具体操作方式.

[vfs]: https://en.wikipedia.org/wiki/Virtual_file_system -->
To realize the concept of "everything is a file," we need to extend our previously implemented file operations:
We need to support not only ordinary file read and write operations but also operations on various "special files."
The way to extend this is something you are already familiar with, which is abstraction!

We extend the semantics of the previously implemented file operation APIs to support operations on any file (including "special files"):
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
This set of extended APIs has a cool name, called [VFS (Virtual File System)][vfs].
Since there is a virtual file system, there should correspondingly be "real file systems,"
which actually refer to how to operate a certain type of file.
For example, in Nanos-lite, ordinary files are operated through the ramdisk API;
in real operating systems, there are countless types of real file systems:
for instance, those familiar with Windows should know about NTFS for managing ordinary files, while EXT4 is currently popular on GNU/Linux;
as for special files, there are even more types, hence there are `procfs`, `tmpfs`, `devfs`, `sysfs`, `initramfs`...
These different real file systems each implement the specific operation methods for these files.

[vfs]: https://en.wikipedia.org/wiki/Virtual_file_system

<!-- 所以, VFS其实是对不同种类的真实文件系统的抽象,
它用一组API来描述了这些真实文件系统的抽象行为, 屏蔽了真实文件系统之间的差异,
上层模块(比如系统调用处理函数)不必关心当前操作的文件具体是什么类型,
只要调用这一组API即可完成相应的文件操作.
有了VFS的概念, 要添加一个真实文件系统就非常容易了:
只要把真实文件系统的访问方式包装成VFS的API,
上层模块无需修改任何代码, 就能支持一个新的真实文件系统了. -->
Therefore, VFS is actually an abstraction of different types of real file systems,
using a set of APIs to describe the abstract behavior of these real file systems, masking the differences between real file systems,
upper layers (such as system call handling functions) do not need to worry about the specific type of file being operated on,
simply calling this set of APIs can complete the corresponding file operations.
With the concept of VFS, adding a real file system becomes very easy:
just wrap the access method of the real file system into the VFS API,
upper layers do not need to modify any code to support a new real file system.

<!-- > #### caution::又来了
> 阅读上述文字的时候, 如果你想起了AM的概念, 这就对了, 因为VFS背后的思想, 也是抽象.

> 在Nanos-lite中, 实现VFS的关键就是`Finfo`结构体中的两个读写函数指针:
> ```c
> typedef struct {
>   char *name;         // 文件名
>   size_t size;        // 文件大小
>   size_t disk_offset;  // 文件在ramdisk中的偏移
>   ReadFn read;        > 读函数指针
>   WriteFn write;      > 写函数指针
> } Finfo;
> ```
> 其中`ReadFn`和`WriteFn`分别是两种函数指针, 它们用于指向真正进行读写的函数, 并返回成功读写的字节数.
> 有了这两个函数指针, 我们只需要在文件记录表中对不同的文件设置不同的读写函数,
> 就可以通过`f->read()`和`f->write()`的方式来调用具体的读写函数了. -->
> #### caution::Here it comes again
> When reading the above text, if you thought of the concept of AM, you're right, because the idea behind VFS is also abstraction.
> In Nanos-lite, the key to implementing VFS is the two read and write function pointers in the `Finfo` structure:
> ```c
> typedef struct {
>   char *name;         // File name
>   size_t size;        // File size
>   size_t disk_offset;  // File offset in ramdisk
>   ReadFn read;        // Read function pointer
>   WriteFn write;      // Write function pointer
> } Finfo;
> ```
> `ReadFn` and `WriteFn` are two types of function pointers, used to point to the actual read and write functions, and return the number of bytes successfully read or written.
> With these two function pointers, we only need to set different read and write functions for different files in the file record table,
> then we can call the specific read and write functions through `f->read()` and `f->write()`.

<!-- > #### comment::用C语言模拟面向对象编程
> VFS的实现展示了如何用C语言来模拟面向对象编程的一些基本概念:
> 例如通过结构体来实现类的定义, 结构体中的普通变量可以看作类的成员,
> 函数指针就可以看作类的方法, 给函数指针设置不同的函数可以实现方法的重载...
>
> 这说明, OOP中那些看似虚无缥缈的概念也没比C语言高级到哪里去,
> 只不过是OOP的编译器帮我们做了更多的事情, 编译成机器代码之后, OOP也就不存在了.
> [Object-Oriented Programming With ANSI-C][ooc]
> 这本书专门介绍了如何用ANSI-C来模拟OOP的各种概念和功能.
> 在GNU/Linux的内核代码中, 很多地方也有OOP的影子. -->
> #### comment::Simulating Object-Oriented Programming in C
> The implementation of VFS demonstrates how to simulate some basic concepts of object-oriented programming in C:
> for example, using structures to define classes, where ordinary variables in structures can be seen as class members,
> function pointers can be seen as class methods, setting different functions to function pointers can achieve method overloading...
>
> This shows that those seemingly ethereal concepts in OOP are not much more advanced than C,
> it's just that the OOP compiler does more for us, and after compiling into machine code, OOP ceases to exist.
> [Object-Oriented Programming With ANSI-C][ooc]
> This book specifically introduces how to simulate various concepts and functionalities of OOP in ANSI-C.
> In the kernel code of GNU/Linux, there are also traces of OOP.

[ooc]: https://www.cs.rit.edu/~ats/books/ooc.pdf


<!-- 不过在Nanos-lite中, 由于特殊文件的数量很少, 我们约定, 当上述的函数指针为`NULL`时,
表示相应文件是一个普通文件, 通过ramdisk的API来进行文件的读写,
这样我们就不需要为大多数的普通文件显式指定ramdisk的读写函数了. -->
However, in Nanos-lite, since there are very few special files, we have agreed that when the above function pointer is `NULL`,
it indicates that the corresponding file is a regular file, which should be read and written through the ramdisk's API,
thus, we do not need to explicitly specify the ramdisk's read and write functions for most regular files.

<!-- 我们把文件看成字节序列, 大部分字节序列都是"静止"的, 例如对于ramdisk和磁盘上的文件,
如果我们不对它们进行修改, 它们就会一直位于同一个地方, 这样的字节序列具有"位置"的概念;
但有一些特殊的字节序列并不是这样, 例如键入按键的字节序列是"流动"的,
被读出之后就不存在了, 这样的字节序列中的字节之间只有顺序关系, 但无法编号, 因此它们没有"位置"的概念.
属于前者的文件支持`lseek`操作, 存储这些文件的设备称为"块设备";
而属于后者的文件则不支持`lseek`操作, 相应的设备称为"字符设备".
真实的操作系统还会对`lseek`操作进行抽象, 我们在Nanos-lite中进行了简化, 就不实现这一抽象了. -->
We view files as sequences of bytes, most of which are "static", for example, files on ramdisk and disks,
if we do not modify them, they will always be in the same place, such byte sequences have the concept of "location";
however, some special byte sequences are not like this, for example, the byte sequence of typing keys is "flowing",
once read, it no longer exists, the bytes in such sequences only have a sequential relationship, but cannot be numbered, therefore, they do not have the concept of "location".
Files of the former type support the `lseek` operation, and the devices that store these files are called "block devices";
while files of the latter type do not support the `lseek` operation, and the corresponding devices are called "character devices".
Real operating systems also abstract the `lseek` operation, but we have simplified it in Nanos-lite and do not implement this abstraction.

### 操作系统之上的IOE

<!-- 有了VFS, 要把IOE抽象成文件就非常简单了. -->
With VFS, it becomes very simple to abstract IOE as files.

<!-- 首先当然是来看最简单的输出设备: 串口.
在Nanos-lite中, `stdout`和`stderr`都会输出到串口.
之前你可能会通过判断`fd`是否为`1`或`2`, 来决定`sys_write()`是否写入到串口.
现在有了VFS, 我们就不需要让系统调用处理函数关心这些特殊文件的情况了:
我们只需要在`nanos-lite/src/device.c`中实现`serial_write()`,
然后在文件记录表中设置相应的写函数, 就可以实现上述功能了.
由于串口是一个字符设备, 对应的字节序列没有"位置"的概念,
因此`serial_write()`中的`offset`参数可以忽略.
另外Nanos-lite也不打算支持`stdin`的读入, 因此在文件记录表中设置相应的报错函数即可. -->
First, let's look at the simplest output device: the serial port.
In Nanos-lite, both `stdout` and `stderr` output to the serial port.
Previously, you might decide whether `sys_write()` writes to the serial port based on whether `fd` is `1` or `2`.
Now with VFS, we no longer need to let the system call handler worry about these special files:
we just need to implement `serial_write()` in `nanos-lite/src/device.c`,
and then set the corresponding write function in the file record table to achieve the above function.
Since the serial port is a character device, the corresponding byte sequence does not have the concept of "location",
thus, the `offset` parameter in `serial_write()` can be ignored.
Additionally, Nanos-lite does not intend to support reading from `stdin`, so an appropriate error function can be set in the file record table.

<!-- > #### todo::把串口抽象成文件
> 根据上述内容, 让VFS支持串口的写入.  -->
> #### todo::Abstract the serial port as a file
> Based on the above content, let VFS support writing to the serial port.

<!-- 关于输入设备, 我们先来看看时钟. 时钟比较特殊, 大部分操作系统并没有把它抽象成一个文件,
而是直接提供一些和时钟相关的系统调用来给用户程序访问.
在Nanos-lite中, 我们也提供一个`SYS_gettimeofday`系统调用,
用户程序可以通过它读出当前的系统时间. -->
Regarding input devices, let's first look at the clock. The clock is quite special, most operating systems do not abstract it as a file,
but directly provide some clock-related system calls for user programs to access.
In Nanos-lite, we also provide a `SYS_gettimeofday` system call,
through which user programs can read the current system time.

<!-- > #### todo::实现gettimeofday
> 实现`gettimeofday`系统调用, 这一系统调用的参数含义请RTFM.
> 实现后, 在`navy-apps/tests/`中新增一个`timer-test`测试,
> 在测试中通过`gettimeofday()`获取当前时间, 并每过0.5秒输出一句话.  -->
> #### todo::Implement gettimeofday
> Implement the `gettimeofday` system call, please RTFM for the meaning of the parameters of this system call.
> After implementation, add a `timer-test` test in `navy-apps/tests/`,
> in the test, obtain the current time through `gettimeofday()`, and output a sentence every 0.5 seconds.

<!-- 为了更好地封装IOE的功能, 我们在Navy中提供了一个叫NDL(NJU DirectMedia Layer)的多媒体库.
这个库的代码位于`navy-apps/libs/libndl/NDL.c`中, 但大部分的功能都没有实现.
代码中有一些和`NWM_APP`相关的内容, 你目前可以忽略它们,
但不要修改相关代码, 你将会在PA4的最后体验相关的功能.
NDL向用户提供了一个和时钟相关的API:
```c
// 以毫秒为单位返回系统时间
uint32_t NDL_GetTicks();
```
 -->
To better encapsulate the functionality of IOE, we provide a multimedia library called NDL (NJU DirectMedia Layer) in Navy.
The code for this library is located in `navy-apps/libs/libndl/NDL.c`, but most of its functions are not implemented.
There are some contents related to `NWM_APP` in the code, which you can ignore for now,
but do not modify the related code, you will experience its functionality at the end of PA4.
NDL provides users with a clock-related API:
```c
// Returns the system time in milliseconds
uint32_t NDL_GetTicks();
```

<!-- > #### todo::实现NDL的时钟
> 你需要用`gettimeofday()`实现`NDL_GetTicks()`,
> 然后修改`timer-test`测试, 让它通过调用`NDL_GetTicks()`来获取当前时间.
> 你可以根据需要在`NDL_Init()`和`NDL_Quit()`中添加初始化代码和结束代码,
> 我们约定程序在使用NDL库的功能之前必须先调用`NDL_Init()`.
> 如果你认为无需添加初始化代码, 则无需改动它们.  -->
> #### todo::Implement NDL's clock
> You need to use `gettimeofday()` to implement `NDL_GetTicks()`,
> and then modify the `timer-test` test, letting it obtain the current time by calling `NDL_GetTicks()`.
> You can add initialization and termination code in `NDL_Init()` and `NDL_Quit()` as needed,
> we agree that the program must call `NDL_Init()` before using the functions of the NDL library.
> If you think there is no need to add initialization code, then there is no need to change them.

<!-- 另一个输入设备是键盘, 按键信息对系统来说本质上就是到来了一个事件.
一种简单的方式是把事件以文本的形式表现出来, 我们定义以下两种事件,
* 按下按键事件, 如`kd RETURN`表示按下回车键
* 松开按键事件, 如`ku A`表示松开`A`键

按键名称与AM中的定义的按键名相同, 均为大写. 此外, 一个事件以换行符`\n`结束.

我们采用文本形式来描述事件有两个好处,
首先文本显然是一种字节序列, 这使得事件很容易抽象成文件;
此外文本方式使得用户程序可以容易可读地解析事件的内容.
Nanos-lite和Navy约定, 上述事件抽象成一个特殊文件`/dev/events`,
它需要支持读操作, 用户程序可以从中读出按键事件,
但它不必支持`lseek`, 因为它是一个字符设备. -->
Another input device is the keyboard, the key information is essentially an event for the system.
A simple way is to represent the event in text form, we define the following two events,
* Key down event, such as `kd RETURN` means pressing the Enter key
* Key up event, such as `ku A` means releasing the `A` key

The names of the keys are the same as those defined in AM, all in uppercase. In addition, an event ends with a newline character `\n`.

There are two advantages to using text to describe events,
first, text is obviously a sequence of bytes, which makes it easy to abstract events into files;
furthermore, the textual method makes it easy for user programs to parse the content of events.
Nanos-lite and Navy agree, the above events are abstracted into a special file `/dev/events`,
it needs to support read operations, user programs can read key events from it,
but it does not need to support `lseek`, because it is a character device.

<!-- NDL向用户提供了一个和按键事件相关的API:
```c
// 读出一条事件信息, 将其写入`buf`中, 最长写入`len`字节
// 若读出了有效的事件, 函数返回1, 否则返回0
int NDL_PollEvent(char *buf, int len);
```-->
NDL provides users with an API related to key events:
```c
// Reads an event information and writes it into `buf`, up to `len` bytes
// If a valid event is read, the function returns 1, otherwise it returns 0
int NDL_PollEvent(char *buf, int len);
```

> <!-- #### todo::把按键输入抽象成文件
> 你需要:
> * 实现`events_read()`(在`nanos-lite/src/device.c`中定义),
> 把事件写入到`buf`中, 最长写入`len`字节, 然后返回写入的实际长度.
> 其中按键名已经在字符串数组`names`中定义好了, 你需要借助IOE的API来获得设备的输入.
> 另外, 若当前没有有效按键, 则返回0即可.
> * 在VFS中添加对`/dev/events`的支持.
> * 在NDL中实现`NDL_PollEvent()`, 从`/dev/events`中读出事件并写入到`buf`中.
>
> 我们可以假设一次最多只会读出一个事件, 这样可以简化你的实现.
> 实现后, 让Nanos-lite运行`navy-apps/tests/event-test`, 如果实现正确,
> 敲击按键时程序会输出按键事件的信息. -->
> #### todo::Abstract key input as a file
> You need to:
> * Implement `events_read()` (defined in `nanos-lite/src/device.c`),
> write the event into `buf`, up to `len` bytes, and then return the actual length written.
> The key names are already defined in the string array `names`, you need to use the IOE's API to get the device input.
> Additionally, if there are no valid keys currently, return 0.
> * Add support for `/dev/events` in VFS.
> * Implement `NDL_PollEvent()` in NDL, reading events from `/dev/events` and writing them into `buf`.
>
> We can assume that at most one event will be read at a time, which can simplify your implementation.
> After implementation, run `navy-apps/tests/event-test` on Nanos-lite, if implemented correctly,
> striking a key will output the key event information.

<!-- > #### hint::用fopen()还是open()?
> 这是个非常值得思考的问题. 你需要思考这两组API具体行为的区别,
> 然后分析`/dev/events`这个特殊文件应该用哪种函数来操作.
> 我们已经在某一个蓝色信息框中给出一些提示了. -->
> #### hint::Use fopen() or open()?
> This is a very worthwhile question to consider. You need to think about the differences in the specific behaviors of these two sets of APIs,
> and then analyze which function should be used to operate on the special file `/dev/events`.
> We have already provided some hints in a blue information box.

<!-- 最后是VGA, 程序为了更新屏幕, 只需要将像素信息写入VGA的显存即可.
于是, Nanos-lite需要做的, 便是把显存抽象成文件.
显存本身也是一段存储空间, 它以行优先的方式存储了将要在屏幕上显示的像素.
Nanos-lite和Navy约定, 把显存抽象成文件`/dev/fb`(fb为frame buffer之意),
它需要支持写操作和`lseek`, 以便于把像素更新到屏幕的指定位置上. -->
Finally, for VGA, to update the screen, the program only needs to write pixel information into VGA's video memory.
Thus, what Nanos-lite needs to do is to abstract the video memory into a file.
The video memory itself is also a storage space, storing the pixels to be displayed on the screen in a row-major order.
Nanos-lite and Navy agree to abstract the video memory into the file `/dev/fb` (fb stands for frame buffer),
it needs to support write operations and `lseek`, in order to update the pixels to a specified position on the screen.

<!-- NDL向用户提供了两个和绘制屏幕相关的API:
```c
// 打开一张(*w) X (*h)的画布
// 如果*w和*h均为0, 则将系统全屏幕作为画布, 并将*w和*h分别设为系统屏幕的大小
void NDL_OpenCanvas(int *w, int *h);

// 向画布`(x, y)`坐标处绘制`w*h`的矩形图像, 并将该绘制区域同步到屏幕上
// 图像像素按行优先方式存储在`pixels`中, 每个像素用32位整数以`00RRGGBB`的方式描述颜色
void NDL_DrawRect(uint32_t *pixels, int x, int y, int w, int h);
```
其中"画布"是一个面向程序的概念, 程序绘图时的坐标都是针对画布来设定的,
这样程序就无需关心系统屏幕的大小, 以及需要将图像绘制到系统屏幕的哪一个位置.
NDL可以根据系统屏幕大小以及画布大小, 来决定将画布"贴"到哪里,
例如贴到屏幕左上角或者居中, 从而将画布的内容写入到frame buffer中正确的位置. -->
NDL provides users with two APIs related to screen drawing:
```c
// Opens a canvas of size (*w) X (*h)
// If both *w and *h are 0, then the entire system screen is used as the canvas, and *w and *h are set to the size of the system screen
void NDL_OpenCanvas(int *w, int *h);

// Draws a rectangle image of size `w*h` at the canvas coordinates `(x, y)`, and synchronizes the drawn area to the screen
// The image pixels are stored in `pixels` in a row-major order, each pixel described by a 32-bit integer in `00RRGGBB` format
void NDL_DrawRect(uint32_t *pixels, int x, int y, int w, int h);
```
Here, "canvas" is a concept oriented towards the program, and the coordinates for drawing in the program are set relative to the canvas,
thus the program does not need to worry about the size of the system screen or where on the system screen the image needs to be drawn.
NDL can decide where to "paste" the canvas based on the size of the system screen and the size of the canvas,
for example, pasting it in the top left corner or centering it, thus writing the content of the canvas to the correct position in the frame buffer.

<!-- `NDL_DrawRect()`的功能和PA2中介绍的绘图接口是非常类似的.
但为了实现它, NDL还需要知道屏幕大小的信息.
Nanos-lite和Navy约定, 屏幕大小的信息通过`/proc/dispinfo`文件来获得, 它需要支持读操作.
`navy-apps/README.md`中对这个文件内容的格式进行了约定, 你需要阅读它.
至于具体的屏幕大小, 你需要通过IOE的相应API来获取. -->
The functionality of `NDL_DrawRect()` is very similar to the drawing interface introduced in PA2.
However, to implement it, NDL also needs to know the size of the screen.
Nanos-lite and Navy agree that the information about the screen size is obtained through the `/proc/dispinfo` file, which needs to support read operations.
The format of this file's content is specified in `navy-apps/README.md`, which you need to read.
As for the specific screen size, you need to obtain it through the corresponding API of IOE.

<!-- > #### todo::在NDL中获取屏幕大小
> * 实现`dispinfo_read()`(在`nanos-lite/src/device.c`中定义),
> 按照约定将文件的`len`字节写到`buf`中(我们认为这个文件不支持`lseek`, 可忽略`offset`).
> * 在NDL中读出这个文件的内容, 从中解析出屏幕大小, 然后实现`NDL_OpenCanvas()`的功能.
> 目前`NDL_OpenCanvas()`只需要记录画布的大小就可以了, 当然我们要求画布大小不能超过屏幕大小.
>
> 让Nanos-lite运行`navy-apps/tests/bmp-test`, 由于目前还没有实现绘图功能,
> 因此无法输出图像内容, 但你可以先通过`printf()`输出解析出的屏幕大小. -->
> #### todo::Retrieve screen size in NDL
> * Implement `dispinfo_read()` (defined in `nanos-lite/src/device.c`),
> write the file's `len` bytes into `buf` (we assume this file does not support `lseek`, so `offset` can be ignored).
> * Read the content of this file in NDL, parse the screen size from it, and then implement the functionality of `NDL_OpenCanvas()`.
> Currently, `NDL_OpenCanvas()` only needs to record the size of the canvas, of course, we require that the canvas size does not exceed the screen size.
>
> Run Nanos-lite with `navy-apps/tests/bmp-test`, since the drawing functionality is not yet implemented,
> you cannot output image content, but you can first use `printf()` to output the parsed screen size.

<!-- > #### todo::把VGA显存抽象成文件
> * 在`init_fs()`(在`nanos-lite/src/fs.c`中定义)中对文件记录表中`/dev/fb`的大小进行初始化.
> * 实现`fb_write()`(在`nanos-lite/src/device.c`中定义), 用于把`buf`中的`len`字节写到屏幕上`offset`处.
> 你需要先从`offset`计算出屏幕上的坐标, 然后调用IOE来进行绘图.
> 另外我们约定每次绘图后总是马上将frame buffer中的内容同步到屏幕上.
> * 在NDL中实现`NDL_DrawRect()`, 通过往`/dev/fb`中的正确位置写入像素信息来绘制图像.
> 你需要梳理清楚系统屏幕(即frame buffer), `NDL_OpenCanvas()`打开的画布,
> 以及`NDL_DrawRect()`指示的绘制区域之间的位置关系.
>
> 让Nanos-lite运行`navy-apps/tests/bmp-test`, 如果实现正确, 你将会看到屏幕上显示Project-N的logo. -->
> #### todo::Abstract VGA video memory as a file
> * Initialize the size of `/dev/fb` in the file record table in `init_fs()` (defined in `nanos-lite/src/fs.c`).
> * Implement `fb_write()` (defined in `nanos-lite/src/device.c`), to write `len` bytes from `buf` to the screen at `offset`.
> You need to calculate the screen coordinates from `offset` first, then call IOE to perform the drawing.
> Additionally, we agree that after each drawing, the content in the frame buffer is always immediately synchronized to the screen.
> * Implement `NDL_DrawRect()` in NDL, by writing pixel information to the correct position in `/dev/fb` to draw the image.
> You need to clearly understand the positional relationship between the system screen (i.e., frame buffer), the canvas opened by `NDL_OpenCanvas()`,
> and the drawing area indicated by `NDL_DrawRect()`.
>
> Run Nanos-lite with `navy-apps/tests/bmp-test`, if implemented correctly, you will see the Project-N logo displayed on the screen.

<!-- > #### option::实现居中的画布
> 你可以根据屏幕大小和画布大小, 让NDL将图像绘制到屏幕的中央, 从而获得较好的视觉效果. -->
> #### option::Implement a centered canvas
> Based on the size of the screen and the canvas, you can have NDL draw the image in the center of the screen, thus achieving a better visual effect.
