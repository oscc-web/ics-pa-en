
<!-- ## 表达式求值 -->
## Expression evaluation

<!-- 在TRM中, 寄存器(包括PC)和内存中的值唯一地确定了计算机的一个状态.
因此从道理上来讲, 打印寄存器和扫描内存这两个功能一定可以帮助我们调试出所有的问题.
但为了方便使用, 我们还希望简易调试器能帮我们计算一些带有寄存器和内存的表达式.
所以你需要在简易调试器中添加表达式求值的功能.
为了简单起见, 我们先来考虑数学表达式的求值实现. -->
In TRM, the values in the registers (including the PC) and memory uniquely determine one unique state of the computer. So it stands to reason that printing the registers and scanning the memory must be able to help us debug all the problems. But for ease of use, we also want the simple debugger to help us compute expressions with registers and memory. That's why you need to add expression evaluation functionality to the simple debugger. For the sake of simplicity, let's consider the implementation of math expression evaluation first.

<!-- ### 数学表达式求值 -->
### Mathematical expression evaluation

<!-- 给你一个表达式的字符串 -->
You are given a string of expressions
```
"5 + 4 * 3 / 2 - 1"
```
<!-- 你如何求出它的值?
表达式求值是一个很经典的问题, 以至于有很多方法来解决它.
我们在所需知识和难度两方面做了权衡, 在这里使用如下方法来解决表达式求值的问题:
1. 首先识别出表达式中的单元
1. 根据表达式的归纳定义进行递归求值 -->
How do you find its value? Expression evaluation is such a classic problem that there are many ways to solve it. We have weighed the knowledge required against the difficulty, and here we use the following approach to solving expression evaluation: 

1. first identify all the units in the expression
2. recursively evaluate the expression according to its inductive definition.

<!-- #### 词法分析 -->
#### Lexical Analysis

<!-- "词法分析"这个词看上去很高端, 说白了就是做上面的第1件事情, "识别出表达式中的单元".
这里的"单元"是指有独立含义的子串, 它们正式的称呼叫token.
具体地说, 我们需要在上述表达式中识别出`5`, `+`, `4`, `*`, `3`, `/`, `2`, `-`, `1`这些token.
你可能会觉得这是一件很简单的事情, 但考虑以下的表达式: -->
"Lexical analysis" is a fancy word for doing the first thing above, "identifying all the units in an expression". A "unit" in this case is a substring with its own meaning, formally known as a token. Specifically, we need to identify the tokens `5`, `+`, `4`, `*`, `3`, `/`, `2`, `-`, and `1` in the above expression. You might think that's a pretty simple thing to do, but consider the following expression.
```
"0x80100000+   ($a0 +5)*4 - *(  $t1 + 8) + number"
```
<!-- 它包含更多的功能, 例如十六进制整数(`0x80100000`), 小括号,
访问寄存器(`$a0`), 指针解引用(第二个`*`), 访问变量(`number`).
事实上, 这种复杂的表达式在调试过程中经常用到,
而且你需要在空格数目不固定(0个或多个)的情况下仍然能正确识别出其中的token.
当然你仍然可以手动进行处理(如果你喜欢挑战性的工作的话), 一种更方便快捷的做法是使用正则表达式.
正则表达式可以很方便地匹配出一些复杂的pattern, 是程序员必须掌握的内容.
如果你从来没有接触过正则表达式, 请查阅相关资料.
在实验中, 你只需要了解正则表达式的一些基本知识就可以了(例如元字符). -->
It contains many more features, such as hexadecimal integers (`0x80100000`), parentheses, access to registers (`$a0`), pointer dereferencing (the second `*`), and access to variables (`number`). In fact, such complex expressions are often used during debugging, and you need to be able to correctly recognize tokens with a variable number of spaces (zero or more). Of course, you can still do this manually (if you like challenging work), and a quicker and easier way to do it is to use regular expressions. Regular expressions make it easy to match complex patterns and are a must for programmers. If you've never encountered regular expressions before, please STFW. In the experiment, you just need to understand some basic knowledge of regular expressions (such as metacharacters).

<!-- 学会使用简单的正则表达式之后, 你就可以开始考虑如何利用正则表达式来识别出token了.
我们先来处理一种简单的情况 -- 算术表达式, 即待求值表达式中只允许出现以下的token类型:
* 十进制整数
* `+`, `-`, `*`, `/`
* `(`, `)`
* 空格串(一个或多个空格) -->
Once you've learned how to use simple regular expressions, you can start thinking about how to use regular expressions to recognize tokens. Let's start with a simple case - an arithmetic expression, where only the following token types are allowed in the expression to be evaluated.
* decimal integers
* `+`, `-`, `*`, `/`
* `(`, `)`.
* A collection of spaces  (one or more spaces).

<!-- 首先我们需要使用正则表达式分别编写用于识别这些token类型的规则.
在框架代码中, 一条规则是由正则表达式和token类型组成的二元组.
框架代码中已经给出了`+`和空格串的规则, 其中空格串的token类型是`TK_NOTYPE`,
因为空格串并不参加求值过程, 识别出来之后就可以将它们丢弃了; `+`的token类型是`'+'`.
事实上token类型只是一个整数, 只要保证不同的类型的token被编码成不同的整数就可以了.
框架代码中还有一条用于识别双等号的规则, 不过我们现在可以暂时忽略它. -->
First we need to write rules to recognize each of these token types using regular expressions. In the framework code, a rule is a pair (implemented with C struct) consisting of a regular expression and a token type. The framework code already gives rules for `+` and collection of spaces, where the token type for collection of spaces is `TK_NOTYPE`, since collection of spaces don't take part in the evaluation process and can be discarded once recognized, and the token type for `+` is `'+'`. In fact, the token type is just an integer, so just make sure that different types of tokens are encoded as different integers. There is also a rule in the framework code that recognizes double equals signs, but we can ignore it for now.

<!-- 这些规则会在简易调试器初始化的时候通过`init_regex()`被编译成一些用于进行pattern匹配的内部信息,
这些内部信息是被库函数使用的, 而且它们会被反复使用, 但你不必关心它们如何组织.
但如果正则表达式的编译不通过, NEMU将会触发assertion fail, 此时你需要检查编写的规则是否符合正则表达式的语法. -->
These rules are compiled via `init_regex()` during the initialization of the simple debugger into some internal data structure for pattern matching, which are used by the library functions, and which are used over and over again, but you don't have to worry about how they are organized. However, if the compilation of the regular expression fails, NEMU will trigger an assertion fail, in which case you need to check that the rules you've written conform to the syntax of the regular expression.

<!-- 给出一个待求值表达式, 我们首先要识别出其中的token, 进行这项工作的是`make_token()`函数.
`make_token()`函数的工作方式十分直接, 它用`position`变量来指示当前处理到的位置,
并且按顺序尝试用不同的规则来匹配当前位置的字符串.
当一条规则匹配成功, 并且匹配出的子串正好是`position`所在位置的时候,
我们就成功地识别出一个token, `Log()`宏会输出识别成功的信息.
你需要做的是将识别出的token信息记录下来(一个例外是空格串), 我们使用`Token`结构体来记录token的信息: -->
Given an expression to be evaluated, we first need to recognize the tokens in it, and this is done by the `make_token()` function. The `make_token()` function works in a very straightforward way, it uses the `position` variable to indicate where it is currently processing, and it tries to match the string at the current position with all the rules in order. When a rule matches successfully, and the matched substring is exactly where `position` is, we have successfully recognized a token, and the `Log()` macro outputs a message that the recognition was successful. All you need to do is save the information about the recognized token (with the exception of the space string), and we use the `Token` structure to save the token information:
```c
typedef struct token {
  int type;
  char str[32];
} Token;
```
<!-- 其中`type`成员用于记录token的类型.
大部分token只要记录类型就可以了, 例如`+`, `-`, `*`, `/`, 但这对于有些token类型是不够的:
如果我们只记录了一个十进制整数token的类型, 在进行求值的时候我们还是不知道这个十进制整数是多少.
这时我们应该将token相应的子串也记录下来, `str`成员就是用来做这件事情的.
需要注意的是, `str`成员的长度是有限的, 当你发现缓冲区将要溢出的时候,
要进行相应的处理(思考一下, 你会如何进行处理?), 否则将会造成难以理解的bug.
`tokens`数组用于按顺序存放已经被识别出的token信息, `nr_token`指示已经被识别出的token数目. -->
The `type` member is used to record the type of the token. For most tokens it is sufficient to just record the type, e.g. `+`, `-`, `*`, `/`, but this is not sufficient for some tokens: if we only record the type of a decimal integer token, then when evaluating the token we will still have no idea of what the decimal integer is. We should record the corresponding substring of the token, and the `str` member is used to do this. Note that the `str` member has a finite length, so when you realize that the buffer is about to overflow, you should handle it accordingly (think about it, how would you handle it?) , otherwise it will result in some hard to find bug. The `tokens` array is used to store the recognized tokens in order, and `nr_token` indicates the number of recognized tokens.

<!-- 如果尝试了所有的规则都无法在当前位置识别出token, 识别将会失败,
框架代码会输出当前token的位置(当表达式过长导致在终端里输出需要换行时,
`^`可能无法指示正确的位置, 此时建议通过输出的`position`值来定位token的位置).
这通常是待求值表达式并不合法造成的, `make_token()`函数将返回`false`, 表示词法分析失败. -->
If all the rules tried can not match the token at the current position, the recognition fails, and the framework code outputs the current position of the token (when the expression is too long and requires line breaks in the terminal, `^` may not indicate the correct position, and it is recommended to locate the position of the token by the output `position` value). This is usually the result of a ill-formed expression, and the `make_token()` function will return `false`, indicating that the lexical analysis failed.

<!-- > #### todo::实现算术表达式的词法分析
> 你需要完成以下的内容:
> * 为算术表达式中的各种token类型添加规则, 你需要注意C语言字符串中转义字符的存在和正则表达式中元字符的功能.
> * 在成功识别出token后, 将token的信息依次记录到`tokens`数组中. -->
> #### todo::Implementing lexical analysis of arithmetic expressions
> 
> You need to accomplish the following.
> 
> * Add rules for the various token types in an arithmetic expression. You need to be aware of the presence of escape characters in C strings and the function of metacharacters in regular expressions.
> * After successfully recognizing the token, record the information about the token into the `tokens` array in order.

<!-- > #### caution::调试公理
> * The machine is always right. (机器永远是对的)
>   * Corollary: If the program does not produce the desired output, it is the programmer's fault.
> * Every line of untested code is always wrong. (未测试代码永远是错的)
>   * Corollary: Mistakes are likely to appear in the "must-be-correct" code.
>
> 这两条公理的意思是: 抱怨是没有用的, 接受代码有bug的现实, 耐心调试.
>
> jyy曾经将它们作为fact提出.
> 事实上无数程序员(包括你的学长学姐)在实践当中一次又一次验证了它们的正确性, 因此它们在这里作为公理出现. -->
> #### caution::Debugging axioms
> 
> *   The machine is always right.
>     *   Corollary: If the program does not produce the desired output, it is the programmer's fault.
> *   Every line of untested code is always wrong.
>     *   Corollary: Mistakes are likely to appear in the "must-be-correct" code.
> 
> These two axioms mean: it's no use complaining, accept that the code is buggy, and be patient with debugging.
> 
> Jyy used to present them as facts. In fact, countless programmers (including seniors at your school) have proven them correct over and over again in practice, so here we present them as axioms.

<!-- > #### hint::如何调试
> * 不要使用"目光调试法", 要思考如何用正确的工具和方法帮助调试
>   * 程序设计课上盯着几十行的程序, 你或许还能在大脑中像NEMU那样模拟程序的执行过程;
>     但程序规模大了之后, 很快你就会放弃的: 你的大脑不可能模拟得了一个巨大的状态机
>   * 我们学习计算机是为了学习计算机的工作原理, 而不是学习如何像计算机那样机械地工作
> * 使用`assert()`设置检查点, 拦截非预期情况
>   * 例如`assert(p != NULL)`就可以拦截由空指针解引用引起的段错误
> * 结合对程序执行行为的理解, 使用`printf()`查看程序执行的情况(注意字符串要换行)
>   * `printf()`输出任意信息可以检查代码可达性: 输出了相应信息, 当且仅当相应的代码块被执行
>   * `printf()`输出变量的值, 可以检查其变化过程与原因
> * 使用GDB观察程序的任意状态和行为
>   * 打印变量, 断点, 监视点, 函数调用栈...
>
> 如果你突然觉得上述方法很有道理, 说明你在程序设计课上没有受到该有的训练. -->
> #### hint::How to debug
> 
> * Don't use " gaze debugging ", think about how to use the right tools and methods to help debugging.
>     * Staring at dozens of lines of program in programming class, you may be able to simulate the execution of the program in your brain like NEMU; but after the program gets bigger, you'll soon give up: your brain can't simulate a huge state machine.
>     * We learn about computers to learn how they work, not how to work mechanically like a computer.
> * Use `assert()` to set up checkpoints, to intercept unintended situations.
>     * For example, `assert(p ! = NULL)` can block segmentation errors caused by null pointer dereferences.
> * Use `printf()` to see how a program is executing in conjunction with an understanding of its behavior (note the line breaks in the strings)
>     * `printf()` outputs an arbitrary message that can be used to check code reachability: the corresponding message is output, if and only if the corresponding block of code is executed.
> * `printf()` outputs the value of a variable can check how and why it has changed.
> * Use GDB to observe arbitrary state and behavior of a program.
>     * Print variables, breakpoints, watchpoints, function call stacks...
> 
> If the above suddenly makes sense to you, it means you didn't get the training you needed in your programming class.

<!-- > #### question::为什么printf()的输出要换行?
> 如果不换行, 可能会发生什么?
> 你可以在代码中尝试一下, 并思考原因, 然后STFW对比你的想法. -->
> #### question::Why does the output of printf() need line breaks?
> 
> What might happen if there were no line breaks? You can try it out in code, think about why, and then STFW to compare your ideas.

<!-- > #### caution::系统设计的黄金法则 -- KISS法则
> 这里的`KISS`是`Keep It Simple, Stupid`的缩写, 它的中文翻译是: 不要在一开始追求绝对的完美.
>
> 你已经学习过程序设计基础, 这意味着你已经学会写程序了, 但这并不意味着你可以顺利地完成PA,
> 因为在现实世界中, 我们需要的是可以运行的system, 而不是求阶乘的小程序.
> NEMU作为一个麻雀虽小, 五脏俱全的小型系统, 其代码量达到3000多行(不包括空行).
> 随着PA的进行, 代码量会越来越多, 各个模块之间的交互也越来越复杂,
> 工程的维护变得越来越困难, 一个很弱智的bug可能需要调好几天.
> 在这种情况下, 系统能跑起来才是王道, 跑不起来什么都是浮云, 追求面面俱到只会增加代码维护的难度.
>
> 唯一可以把你从bug的混沌中拯救出来的就是KISS法则,
> 它的宗旨是**从易到难, 逐步推进**, 一次只做一件事, 少做无关的事.
> 如果你不知道这是什么意思, 我们以上文提到的`str`成员缓冲区溢出问题来作为例子.
> KISS法则告诉你, 你应该使用`assert(0)`, 就算不"得体"地处理上述问题, 仍然不会影响表达式求值的核心功能的正确性.
> 如果你还记得调试公理, 你会发现两者之间是有联系的: 调试公理第二点告诉你, 未测试代码永远是错的.
> 与其一下子写那么多"错误"的代码, 倒不如使用`assert(0)`来有效帮助你减少这些"错误".
>
> 如果把KISS法则放在软件工程领域来解释, 它强调的就是多做[单元测试][unit test]:
> 写一个函数, 对它进行测试, 正确之后再写下一个函数, 再对它进行测试...
> 一种好的测试方式是使用assertion进行验证, `reg_test()`就是这样的例子.
> 学会使用assertion, 对程序的测试和调试都百利而无一害.
>
> KISS法则不但广泛用在计算机领域, 就连其它很多领域也视其为黄金法则,
> [这里][kiss]有一篇文章举出了很多的例子, 我们强烈建议你阅读它, 体会KISS法则的重要性.

[unit test]: http://en.wikipedia.org/wiki/Unit_testing
[kiss]: http://blog.sciencenet.cn/blog-414166-562616.html -->
> #### caution::The Golden Rule of System Design -- The KISS Rule
> 
> The `KISS` here is an abbreviation for `Keep It Simple, Stupid`, which translates to: Don't Strive for Absolute Perfection in the Beginning.
> 
> You've learned the basics of programming, which means you've learned to write programs, but that doesn't mean you're ready for PA just yet, because in the real world, we need systems that work, not little programs that find factorials. NEMU is a small system with a code size of more than 3000 lines (excluding blank lines). As the PA progresses, the amount of code will be increasingly large, and the interaction between modules will be more and more complex, and the maintenance of the project will become very difficult, and a very retarded bug may need to be debugged for several days. In this case, the system can work is the king, anything not functional is useless. The pursuit of everything will only increase the difficulty of code maintenance.
> 
> The only thing that can save you from the chaos of bugs is the KISS rule, which is about **from easy to hard, step by step**, one thing at a time, and fewer irrelevant things. If you don't know what this means, let's take the `str` member buffer overflow problem mentioned above as an example. The KISS rule tells you that you should use `assert(0)`, which, even if it doesn't handle the above problem "properly", still doesn't affect the correctness of the core function of expression evaluation. If you remember the debugging axiom, you'll see that the two are related: the second point of the debugging axiom tells you that untested code is always wrong. Instead of writing so much "wrong" code all at once, you can use `assert(0)` to help minimize these "mistakes".
> 
> If you interpret the KISS rule in the context of software engineering, it emphasizes the importance of doing [unit tests](https://en.wikipedia.org/wiki/Unit_testing): write a function, test it, write the next function and test it again ... A good way to test is to use assertions, `reg_test()` is an example. Learning how to use assertions can be beneficial for both testing and debugging your program.
> 
> The KISS rule is widely used not only in computing, but in many other fields as well, and [here](http://blog.sciencenet.cn/blog-414166-562616.html) is an article with many examples, which we highly recommend you read, to realize the importance of the KISS rule. 

<!-- #### 递归求值 -->
#### Recursive evaluation

<!-- 把待求值表达式中的token都成功识别出来之后, 接下来我们就可以进行求值了.
需要注意的是, 我们现在是在对tokens数组进行处理, 为了方便叙述, 我们称它为"token表达式".
例如待求值表达式 -->
Once the tokens in the expression have been recognized, we can proceed with the evaluation. Note that we are now working with an array of tokens, which we will refer to as a "token expression" for convenience. For example, the expression to be evaluated is
```
"4 +3*(2- 1)"
```
<!-- 的token表达式为 -->
has the token expression
```
+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| NUM | '+' | NUM | '*' | '(' | NUM | '-' | NUM | ')' |
| "4" |     | "3" |     |     | "2" |     | "1" |     |
+-----+-----+-----+-----+-----+-----+-----+-----+-----+
```

<!-- 根据表达式的归纳定义特性, 我们可以很方便地使用递归来进行求值.
首先我们给出算术表达式的归纳定义: -->
By the inductive definition nature of expressions, we can easily use recursion to evaluate them. First we give the inductive definition of an arithmetic expression.
<!-- ```
<expr> ::= <number>    # 一个数是表达式
  | "(" <expr> ")"     # 在表达式两边加个括号也是表达式
  | <expr> "+" <expr>  # 两个表达式相加也是表达式
  | <expr> "-" <expr>  # 接下来你全懂了
  | <expr> "*" <expr>
  | <expr> "/" <expr>
``` -->
```
<expr> ::= <number>    # a number is an expression
  | "(" <expr> ")"     # Adding parentheses to both sides of an expression is also an expression
  | <expr> "+" <expr>  # Adding two expressions is also an expression
  | <expr> "-" <expr>  # Next you get it all!
  | <expr> "*" <expr>
  | <expr> "/" <expr>
```
<!-- 上面这种表示方法就是大名鼎鼎的[BNF][bnf],
任何一本正规的程序设计语言教程都会使用BNF来给出这种程序设计语言的语法.

[bnf]: http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form -->
The above representation is the well-known [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form), which is used by any formal programming language tutorial to give the syntax of the programming language.

<!-- 根据上述BNF定义, 一种解决方案已经逐渐成型了:
既然长表达式是由短表达式构成的, 我们就先对短表达式求值, 然后再对长表达式求值.
这种十分自然的解决方案就是[分治法][daq]的应用,
就算你没听过这个高大上的名词, 也不难理解这种思路.
而要实现这种解决方案, 递归是你的不二选择.

[daq]: http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms -->
Based on the above BNF definition, a solution has developed: since a long expression is composed of short expressions, we evaluate the short expression first, and then evaluate the long expression. This natural solution is the application of [divide-and-conquer](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms), which is easy to understand even if you haven't heard of this fancy term. And to implement this solution, recursion is the way to go.


<!-- 为了在token表达式中指示一个子表达式, 我们可以使用两个整数`p`和`q`来指示这个子表达式的开始位置和结束位置.
这样我们就可以很容易把求值函数的框架写出来了: -->
To indicate a sub-expression in a token expression, we can use two integers `p` and `q` to indicate where the sub-expression starts and where it ends. This makes it easy to write out the framework of the evaluation function: `p` and `q`.
```c
eval(p, q) {
  if (p > q) {
    /* Bad expression */
  }
  else if (p == q) {
    /* Single token.
     * For now this token should be a number.
     * Return the value of the number.
     */
  }
  else if (check_parentheses(p, q) == true) {
    /* The expression is surrounded by a matched pair of parentheses.
     * If that is the case, just throw away the parentheses.
     */
    return eval(p + 1, q - 1);
  }
  else {
    /* We should do more things here. */
  }
}
```
<!-- 其中`check_parentheses()`函数用于判断表达式是否被一对匹配的括号包围着,
同时检查表达式的左右括号是否匹配, 如果不匹配, 这个表达式肯定是不符合语法的, 也就不需要继续进行求值了.
我们举一些例子来说明`check_parentheses()`函数的功能: -->
The `check_parentheses()` function is used to determine if an expression is surrounded by a matching pair of parentheses, and to check if the left and right parentheses of an expression match; if they don't match, the expression is ungrammatical, and there's no need to continue evaluating it. Let's see some examples of what the `check_parentheses()` function can do:
```
"(2 - 1)"             // true
"(4 + 3 * (2 - 1))"   // true
"4 + 3 * (2 - 1)"     // false, the whole expression is not surrounded by a matched
                      // pair of parentheses
"(4 + 3)) * ((2 - 1)" // false, bad expression
"(4 + 3) * (2 - 1)"   // false, the leftmost '(' and the rightmost ')' are not matched
```
<!-- 至于怎么检查左右括号是否匹配, 就当作一个程序设计作业, 留给聪明的你来思考吧! -->
As for how to check if the left and right parentheses match, let's leave that as a programming assignment for you to think about!

<!-- 上面的框架已经考虑了BNF中算术表达式的开头两种定义,
接下来我们来考虑剩下的情况(即上述伪代码中最后一个`else`中的内容).
一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式?
我们定义"主运算符"为表达式人工求值时, 最后一步进行运行的运算符,
它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式).
要正确地对一个长表达式进行分裂, 就是要找到它的主运算符.
我们继续使用上面的例子来探讨这个问题: -->
The above framework has considered the first two definitions of arithmetic expressions in BNF, and we'll consider the remaining cases (i.e., what's in the last `else` in the pseudo-code above). One question is, given a long expression whose leftmost and rightmost sides are not both parentheses, how do we properly split it into two sub-expressions? We define the "main operator" as the operator that is run at the last step of the expression when it is evaluated manually, which indicates the type of the expression (e.g. when the last step of an expression is a subtraction operation, it is essentially a subtraction expression). To split a long expression correctly is to find its main operator. We'll continue to explore this issue using the example above.
```
"4 + 3 * ( 2 - 1 )"
/*********************/
case 1:
    "+"
   /   \
"4"     "3 * ( 2 - 1 )"


case 2:
        "*"
       /   \
"4 + 3"     "( 2 - 1 )"


case 3:
              "-"
             /   \
"4 + 3 * ( 2"     "1 )"
```
<!-- 上面列出了3种可能的分裂, 注意到我们不可能在非运算符的token处进行分裂, 否则分裂得到的结果均不是合法的表达式.
根据主运算符的定义, 我们很容易发现, 只有第一种分裂才是正确的.
这其实也符合我们人工求值的过程: 先算`4`和`3 * ( 2 - 1 )`, 最后把它们的结果相加.
第二种分裂违反了算术运算的优先级, 它会导致加法比乘法更早进行.
第三种分裂破坏了括号的平衡, 分裂得到的结果均不是合法的表达式. -->
The three possible splits are listed above, and note that we cannot split at a token that is not an operator, otherwise the result of the split would not be a legal expression. Based on the definition of the main operator, it is easy to see that only the first split is correct. This is consistent with our manual evaluation process: we first calculate `4` and `3 * ( 2 - 1 )`, and then we add their results. The second kind of splitting violates the priority of arithmetic operations, and causes addition to take place before multiplication. The third type of splitting destroys the balance of the parentheses. So the result of the 2nd and 3rd splitting is not a legal expression.

<!-- 通过上面这个简单的例子, 我们就可以总结出如何在一个token表达式中寻找主运算符了:
* 非运算符的token不是主运算符.
* 出现在一对括号中的token不是主运算符.
注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在`check_parentheses()`相应的`if`块中被处理了.
* 主运算符的优先级在表达式中是最低的.
这是因为主运算符是最后一步才进行的运算符.
* 当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符.
一个例子是`1 + 2 + 3`, 它的主运算符应该是右边的`+`. -->
With the simple example above, we can summarize how to find the main operator in a token expression: 

* A token that is not an operator is not a main operator.
* A token that appears in a pair of parentheses is not a principal operator. Notice that there are no parentheses enclosing the entire expression, because this is handled in the corresponding `if` block of `check_parentheses()`. 
* The main operator has the lowest precedence in the expression. This is because the main operator is the last operator to be performed.
* When more than one operator has the lowest priority, the last operator to be combined is the main operator by combinability. An example would be `1 + 2 + 3`, whose main operator would be `+` on the right.

<!-- 要找出主运算符, 只需要将token表达式全部扫描一遍, 就可以按照上述方法唯一确定主运算符. -->
To find the main operator, just loop through the token expression and uniquely identify the main operator as described above.

<!-- 找到了正确的主运算符之后, 事情就变得很简单了:
先对分裂出来的两个子表达式进行递归求值, 然后再根据主运算符的类型对两个子表达式的值进行运算即可.
于是完整的求值函数如下: -->
Once you've found the correct main operator, it's a simple matter of recursively evaluating the two split sub-expressions, and then evaluating the main operator on the values of the two sub-expressions. The complete evaluation function is then as follow:
<!-- ```c
eval(p, q) {
  if (p > q) {
    /* Bad expression */
  }
  else if (p == q) {
    /* Single token.
     * For now this token should be a number.
     * Return the value of the number.
     */
  }
  else if (check_parentheses(p, q) == true) {
    /* The expression is surrounded by a matched pair of parentheses.
     * If that is the case, just throw away the parentheses.
     */
    return eval(p + 1, q - 1);
  }
  else {
    op = the position of 主运算符 in the token expression;
    val1 = eval(p, op - 1);
    val2 = eval(op + 1, q);

    switch (op_type) {
      case '+': return val1 + val2;
      case '-': /* ... */
      case '*': /* ... */
      case '/': /* ... */
      default: assert(0);
    }
  }
}
``` -->
```c
eval(p, q) {
  if (p > q) {
    /* Bad expression */
  }
  else if (p == q) {
    /* Single token.
     * For now this token should be a number.
     * Return the value of the number.
     */
  }
  else if (check_parentheses(p, q) == true) {
    /* The expression is surrounded by a matched pair of parentheses.
     * If that is the case, just throw away the parentheses.
     */
    return eval(p + 1, q - 1);
  }
  else {
    op = the position of main operator in the token expression;
    val1 = eval(p, op - 1);
    val2 = eval(op + 1, q);

    switch (op_type) {
      case '+': return val1 + val2;
      case '-': /* ... */
      case '*': /* ... */
      case '/': /* ... */
      default: assert(0);
    }
  }
}
```
<!-- 需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候,
应该给上层函数返回一个表示出错的标识, 告诉上层函数"求值的结果是无效的".
例如在`check_parentheses()`函数中,
`(4 + 3)) * ((2 - 1)`和`(4 + 3) * (2 - 1)`这两个表达式虽然都返回`false`,
因为前一种情况是表达式不合法, 是没有办法成功进行求值的;
而后一种情况是一个合法的表达式, 是可以成功求值的, 只不过它的形式不属于BNF中的`"(" <expr> ")"`,
需要使用主运算符的方式进行处理, 因此你还需要想办法把它们区别开来.
当然, 你也可以在发现非法表达式的时候使用`assert(0)`终止程序.
不过这样的话, 你在使用表达式求值功能的时候就要十分谨慎了. -->
It is important to note that the above framework does not have error handling, and when an expression is found to be illegal during evaluation, an error flag should be returned to the higher-level function, telling it that "the result of the evaluation is invalid". For example, in the `check_parentheses()` function, `(4 + 3)) * ((2 - 1)` and `(4 + 3) * (2 - 1)` both return `false`, because in the first case, the expression is illegal, and there is no way to succeed in evaluating the value, while in the latter case, it's a legal expression, and the evaluation is successful. The latter case is a legitimate expression that can be evaluated successfully, except that it is not in the form of BNF's `"(" <expr> ")"`, which needs to be handled using the main operator, so you need to find a way to distinguish between them. Of course, you can also use `assert(0)` to terminate the program if you find an illegal expression. In that case, however, you'll need to be very careful about how you use the expression evaluation function.

<!-- 最后, 为了方便统一, 我们认为所有结果都是`uint32_t`类型. -->
Finally, for the sake of consistency, we consider all results to be of type `uint32_t`.

<!-- > #### todo::实现算术表达式的递归求值
> 由于ICS不是算法课, 我们已经把递归求值的思路和框架都列出来了.
> 你需要做的是理解这一思路, 然后在框架中填充相应的内容.
> 实现表达式求值的功能之后, `p`命令也就不难实现了. -->
> #### todo::Implementing recursive evaluation of arithmetic expressions
> 
> Since ICS is not an algorithms class, we have already laid out the idea and framework of recursive evaluation. All you need to do is understand the idea, and fill in the framework accordingly. The `p` command is easy to implement once you have implemented expression evaluation.

<!-- > #### option::实现带有负数的算术表达式的求值 (选做)
> 在上述实现中, 我们并没有考虑负数的问题, 例如
> ```
> "1 + -1"
> "--1"    /* 我们不实现自减运算, 这里应该解释成 -(-1) = 1 */
> ```
> 它们会被判定为不合法的表达式.
> 为了实现负数的功能, 你需要考虑两个问题:
> * 负号和减号都是`-`, 如何区分它们?
> * 负号是个单目运算符, 分裂的时候需要注意什么?
>
> 你可以选择不实现负数的功能, 但你很快就要面临类似的问题了. -->
> #### option::Evaluating Arithmetic Expressions with Negative Numbers (Optional)
> 
> In the above implementation, we did not consider the problem of negative numbers, such as
> 
>     "1 + -1"
>     "--1"    /* We don't implement decrement op, here it should be interpreted as -(-1) = 1 */.
>     
> * The negative sign and the minus sign are both `-`, how can you tell them apart?
> * The minus sign is a unary operator, what do I need to be aware of when splitting?
> 
> You can choose not to implement negative numbers, but you'll soon be facing similar problems.

<!-- > #### comment::从表达式求值窥探编译器
> 你在程序设计课上已经知道, 编译是一个将高级语言转换成机器语言的过程.
> 但你是否曾经想过, 机器是怎么读懂你的代码的?
> 回想你实现表达式求值的过程, 你是否有什么新的体会?
>
> 事实上, 词法分析也是编译器编译源代码的第一个步骤, 编译器也需要从你的源代码中识别出token,
> 这个功能也可以通过正则表达式来完成, 只不过token的类型更多, 更复杂而已.
> 这也解释了你为什么可以在源代码中插入任意数量的空白字符(包括空格, tab, 换行), 而不会影响程序的语义;
> 你也可以将所有源代码写到一行里面, 编译仍然能够通过.
>
> 一个和词法分析相关的有趣的应用是语法高亮.
> 在程序设计课上, 你可能完全没有想过可以自己写一个语法高亮的程序.
> 事实是, 这些看似这么神奇的东西, 其实也没那么复杂, 你现在确实有能力来实现它:
> 把源代码看作一个字符串输入到语法高亮程序中, 在循环中识别出一个token之后,
> 根据token类型用不同的颜色将它的内容重新输出一遍就可以了.
> 如果你打算将高亮的代码输出到终端里, 你可以使用[ANSI转义码的颜色功能][ansi].
>
> 在表达式求值的递归求值过程中, 逻辑上其实做了两件事情:
> 第一件事是根据token来分析表达式的结构(属于BNF中的哪一种情况), 第二件事才是求值.
> 它们在编译器中也有对应的过程: 语法分析就好比分析表达式的结构,
> 只不过编译器分析的是程序的结构, 例如哪些是函数, 哪些是语句等等.
> 当然程序的结构要比表达式的结构更复杂, 因此编译器一般会使用一种标准的框架来分析程序的结构,
> 理解这种框架需要更多的知识, 这里就不展开叙述了.
> 另外如果你有兴趣, 可以看看C语言语法的BNF.
>
> 和表达式最后的求值相对的, 在编译器中就是代码生成.
> ICS理论课会有专门的章节来讲解C代码和汇编指令的关系,
> 即使你不了解代码具体是怎么生成的, 你仍然可以理解它们之间的关系.
> 这是因为C代码天生就和汇编代码有密切的联系, 高水平C程序员的思维甚至可以在C代码和汇编代码之间相互转换.
> 如果要深究代码生成的过程, 你也不难猜到是用递归实现的:
> 例如要生成一个函数的代码, 就先生成其中每一条语句的代码, 然后通过某种方式将它们连接起来.
>
> 我们通过表达式求值的实现来窥探编译器的组成, 是为了落实一个道理:
> 学习汽车制造专业不仅仅是为了学习开汽车, 是要学习发动机怎么设计.
> 我们也强烈推荐你在将来修读"编译原理"课程, 深入学习"如何设计发动机".

[ansi]: http://en.wikipedia.org/wiki/ANSI_escape_code#Colors -->
> #### comment::Peeking into the compiler from expression evaluation
> 
> As you know from your programming classes, compilation is the process of converting a high-level language into machine language. But have you ever wondered how the machine reads your code? Thinking back to your implementation of expression evaluation, did you learn anything new?
> 
> In fact, lexical analysis is the first step in the compiler's process of compiling your source code. The compiler needs to recognize tokens from your source code, and this can also be done with regular expressions, but the types of tokens are more varied and complex. This also explains why you can insert any number of whitespace characters (including spaces, tabs, and line breaks) into your source code without affecting the semantics of your program; you can also write all your source code in a single line and the compilation will still pass.
> 
> An interesting application related to lexical analysis is syntax highlighting. In your programming classes, you may not have thought about writing your own syntax highlighting program. The truth is, this seemingly magical stuff isn't that complicated, and you do have the ability to do it now: think of the source code as a string fed into a syntax highlighting program, and then, after identifying a token, you can just output its contents again in a different color depending on the type of the token. If you want to output the highlighted code to the terminal, you can use the [ANSI escape code color](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors).
> 
> In the recursive evaluation of an expression, two things are done in terms of code logic: the first is to analyze the structure of the expression based on the token (which of the BNF cases it belongs to), and the second is to evaluate it. There is a compiler equivalent: syntax analysis is like analyzing the structure of an expression, except that the compiler analyzes the structure of the program, i.e., which are functions, which are statements, etc. Of course, the structure of a program is more complex than the structure of an expression, so compilers generally use a standard framework for analyzing the structure of a program. Understanding this framework requires a lot more knowledge than we can provide here. Also, if you are interested, you can read the BNF for C syntax.
> 
> The counterpart to the final evaluation of an expression is code generation in the compiler. ICS theory classes have a special section on the relationship between C code and assembly instructions, so even if you don't know exactly how code is generated, you can still understand the relationship. This is because C code is intrinsically linked to assembly code, and highly skilled C programmers can even think in terms of switching between C and assembly code. If you look deeper into the code generation process, you can easily guess that it's done recursively: for example, to generate the code for a function, you first generate the code for each of its statements, and then link them together in some way.
> 
> The reason we're peeking into the compiler's makeup through the expression evaluation implementation is to enforce the idea that studying automotive manufacturing isn't just about learning to drive a car, it's about learning how to design an engine. We also highly recommend that you take the "Principles of Compilation" course in the future for an in-depth study of "how to design an engine".

<!-- ### 如何测试你的代码 -->
### How to test your code

<!-- 你将来是要使用你自己实现的表达式求值功能来帮助你来进行后续的调试的,
这意味着程序设计课上那种"代码随便测试一下就交上去然后就可以撒手不管"的日子已经一去不复返了.
测试需要测试用例, 通过越多测试, 你就会对代码越有信心.
但如果让你来设计测试用例, 设计十几个你就会觉得没意思了,
有没有一种方法来自动产生测试用例呢? -->
You're going to be using your own implementation of expression evaluation to help you with subsequent debugging, which means that the days of "just test the code and turn it in and leave it alone" in your programming class are gone. Tests require test cases, and the more tests you run, the more confidence you'll have in your code. But if you're asked to design test cases, a dozen of them will make you bored already, is there a way to automate the generation of test cases?

<!-- 一种常用的方法是[随机测试][rand test].
首先我们需要来思考如何随机生成一个合法的表达式.
事实上, 表达式生成比表达式求值要容易得多.
同样是上面的BNF, 我们可以很容易写出生成表达式的框架: -->
A common method is [randomized testing](https://en.wikipedia.org/wiki/Random_testing) . First we need to think about how to randomly generate a legal expression. In fact, expression generation is much easier than expression evaluation. Again with the BNF above, it is easy to write a framework for generating an expression.
```c
void gen_rand_expr() {
  switch (choose(3)) {
    case 0: gen_num(); break;
    case 1: gen('('); gen_rand_expr(); gen(')'); break;
    default: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); break;
  }
}
```
<!-- 你应该一眼就能明白上述代码是如何工作的:
其中`uint32_t choose(uint32_t n)`是一个很简单又很重要的函数,
它的作用是生成一个小于`n`的随机数, 所有随机生成的内容几乎都是通过它来选择的. -->
You should be able to understand at first glance how the above code works: `uint32_t choose(uint32_t n)` is a very simple but important function that generates a random number less than `n`, and almost everything that is randomly generated is chosen by it.

<!-- 有了这些随机表达式作为测试输入, 我们怎么知道输出对不对呢?
如果要我们把这些表达式手动算一遍, 那就太麻烦了.
如果可以在生成这些表达式的同时, 也能生成它们的结果, 这样我们就能得到类似OJ的测试用例啦!
但我们在NEMU中实现的表达式求值是经过了一些简化的, 所以我们需要一种满足以下条件的"计算器":
* 进行的都是无符号运算
* 数据宽度都是32bit
* 溢出后不处理 -->
With these random expressions as test input, how do we know if the output is correct? If we have to manually calculate these expressions, it's too much trouble. If we can generate these expressions and their results at the same time, we can get OJ-like test cases! But our implementation of expression evaluation in NEMU is somewhat simplified, so we need a "calculator" that satisfies the following conditions.

* Only unsigned operations are performed
* Data width is 32 bits
* Overflow is not handled

<!-- 嘿! 如果我们把这些表达式塞到如下C程序的源文件里面: -->
Hey, hey, hey! If we stuff these expressions inside the source file of the following C program.
<!-- ```c
#include <stdio.h>
int main() {
  unsigned result = ???; // 把???替换成表达式
  printf("%u", result);
  return 0;
}
``` -->
```c
#include <stdio.h>
int main() {
  unsigned result = ???; // replace ??? with expression
  printf("%u", result);
  return 0;
}
```
<!-- 然后用gcc编译它并执行, 让它输出表达式的结果, 这不就是我们想要的"计算器"吗? -->
Then compiling it with gcc and executing it, so that it outputs the result of the expression, isn't that what we want from a "calculator"?

<!-- 还真能这样做! 我们已经准备好这个表达式生成器的框架代码了(在`nemu/tools/gen-expr/gen-expr.c`中).
你需要实现其中的`void gen_rand_expr()`函数, 将随机生成的表达式输出到缓冲区`buf`中.
`main`函数中的代码会调用你实现的`gen_rand_expr()`,
然后把`buf`中的随机表达式放入上述C程序的代码中.
剩下的事情就是编译运行这个C程序了, 代码中使用了`system()`和`popen()`等库函数来实现这一功能.
最后, 框架代码将这个C程序的打印结果和之前随机生成的表达式一同输出, 这样就生成了一组测试用例. -->
It's indeed possible to do this! We have the framework code for this expression generator already prepared (in `nemu/tools/gen-expr/gen-expr.c`). You need to implement the `void gen_rand_expr()` function, which outputs the randomly generated expression to the buffer `buf`. The code in the `main` function will call your implementation of `gen_rand_expr()`, and then put the random expression in `buf` into the code of the above C program. The only thing left to do is to compile and run the C program, which uses library functions such as `system()` and `popen()` to do this. Finally, the framework code outputs the printout of the C program along with the randomly generated expressions, thus generating a set of test cases.

<!-- > #### question::表达式生成器如何获得C程序的打印结果?
> 代码中这部分的内容没有任何注释, 聪明的你也许马上就反应过来: 竟然是个RTFM的圈套!
> 阅读手册了解API的具体行为可是程序员的基本功.
> 如果觉得去年一整年的程序员都白当了, 就从现在开始好好锻炼吧. -->
> #### question::How does an expression generator get a C program's output?
> 
> There are no comments in this part of the code, and the smartest person might immediately realize that this is a RTFM trap! Reading the manual to understand the behavior of the API is a basic programmer's skill. If you feel like you've spent the last year as a programmer for nothing, start working on it now.

<!-- 不过实现的时候, 你很快就会发现需要面对一些细节的问题:
* 如何保证表达式进行无符号运算?
* 如何随机插入空格?
* 如何生成长表达式, 同时不会使`buf`溢出?
* 如何过滤求值过程中有除0行为的表达式? -->
But when it comes to implementation, you'll soon realize that you'll have to deal with a few other details:

* How do you ensure that expressions perform unsigned operations only?
* How to insert random spaces?
* How to generate long expressions without overflowing the `buf`?
* How to filter out expressions with divide-by-0 behavior during evaluation?

<!-- 这些问题大多都和C语言相关, 就当作是C语言的又一个编程练习吧. -->
Most of these questions are related to C, so consider them as another C programming exercise.

<!-- > #### question::为什么要使用无符号类型? (建议二周目思考)
> 我们在表达式求值中约定, 所有运算都是无符号运算.
> 你知道为什么要这样约定吗? 如果进行有符号运算, 有可能会发生什么问题? -->
> #### question::Why use unsigned types? (Recommended to think about this in the 2nd round)
> 
> We agree in our expressions that all operations are unsigned. Do you know why we agreed on this? What could go wrong if we do signed operations?

<!-- > #### question::除0的确切行为
> 如果生成的表达式有除0行为, 你编写的表达式生成器的行为又会怎么样呢? -->
> #### question::Exact behavior of division by 0
> 
> If the generated expression has a divide-by-0 behavior, what about the behavior of the expression generator you wrote?

<!-- > #### hint::过滤除0行为的表达式
> 乍看之下这个问题不好解决, 因为框架代码只负责生成表达式, 而检测除0行为至少要对表达式进行求值.
> 结合前两个蓝框题的回答(前提是你对它们的理解都足够深入了), 你就会找到解决方案了, 而且解决方案不唯一喔! -->
> #### hint::Filtering Expressions for Divide-by-0 Behavior
> 
> At first glance this looks like a difficult problem to solve, because the framework code is only responsible for generating the expression, and detecting the divide-by-0 behavior requires at least evaluating the expression. Combine the answers to the first two blue-box questions (provided you understand them well enough), you'll find a solution, and it's not the only one!

<!-- > #### todo::实现表达式生成器
> 根据上文内容, 实现表达式生成器. 实现后, 就可以用来生成表达式求值的测试用例了.
> ```
> ./gen-expr 10000 > input
> ```
> 将会生成10000个测试用例到`input`文件中, 其中每行为一个测试用例, 其格式为
> ```
> 结果 表达式
> ```
> 再稍微改造一下NEMU的`main()`函数, 让其读入`input`文件中的测试表达式后,
> 直接调用`expr()`, 并与结果进行比较.
> 为了容纳长表达式的求值, 你还需要对`tokens`数组的大小进行修改.
>
> 随着你的程序通过越来越多的测试, 你会对你的代码越来越有信心. -->
> #### todo::Implementing an expression generator
> 
> Based on the above, implement the expression generator. Once implemented, it can be used to generate test cases for expression evaluation.
> ```
> ./gen-expr 10000 > input
> ```
> 10,000 test cases will be generated into the `input` file, one for each row, in the format of
> ```
> <Result> <Expression>
> ```
> Modify NEMU's `main()` function a bit so that it reads in the test expression from the `input` file, calls `expr()` directly, and compares it to the result. You will also need to modify the size of the `tokens` array to accommodate long expressions.
> 
> As your program passes more and more tests, you'll feel more and more confident in your code.

<!-- > #### flag::温馨提示
> PA1阶段2到此结束. -->
> #### flag::Tips
> 
> This is the end of PA1 Stage 2.
