<!-- ## RTFM -->
## RTFM

<!-- 我们在上一小节中已经在概念上介绍了一条指令具体如何执行, 其中有的概念甚至显而易见得难以展开.
但当我们决定往TRM中添加各种高效指令的同时,
也意味着我们无法回避繁琐的细节.

首先你需要了解指令确切的行为, 为此, 你需要阅读生存手册中指令集相关的章节.
具体地, 无论你选择何种ISA, 相应手册中一般都会有以下内容, 尝试RTFM并寻找这些内容的位置:
* 每一条指令具体行为的描述
* 指令opcode的编码表格

特别地, 由于x86的指令集的复杂性,
我们为选择x86的同学提供了[一个简单的阅读教程](i386-intro.md). -->
We've already covered the concepts of how an instruction is executed in the previous section, some of which are even hard to expand on. But when we decided to add all kinds of efficient instructions to TRM, it also meant that we couldn't avoid the complexity of the details.

The first thing you need to know is the exact behavior of the instructions, and for that you need to read the instruction set section of the survival manual (The official ISA manual). Specifically, whatever ISA you choose, the corresponding manual will usually have the following, so try to RTFM and look for the location of these.

* A description of the specific behavior of each instruction
* a table of instruction opcodes's encoding

In particular, due to the complexity of the x86 instruction set, we have provided [a simple tutorial](i386-intro.html) for those who choose x86.
<!--
> #### comment::RISC - 与CISC平行的另一个世界
> 你是否觉得x86指令集的格式特别复杂?
> 这其实是CISC的一个特性, 不惜使用复杂的指令格式, 牺牲硬件的开发成本,
> 也要使得一条指令可以多做事情, 从而提高代码的密度, 减小程序的大小.
> 随着时代的发展, 架构师发现CISC中复杂的控制逻辑不利于提高处理器的性能, 于是RISC应运而生.
> RISC的宗旨就是简单, 指令少, 指令长度固定, 指令格式统一, 这和KISS法则有异曲同工之妙.
> [这里][risccisc]有一篇对比RISC和CISC的小短文.
>
> 另外值得推荐的是[这篇文章][blog], 里面讲述了一个从RISC世界诞生,
> 到与CISC世界融为一体的故事, 体会一下RISC的诞生对计算机体系结构发展的里程碑意义.

[risccisc]: http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc
[blog]: http://blog.sciencenet.cn/blog-414166-763326.html -->
> #### comment::RISC - Another world parallel to the CISC
>
> Do you think the format of the x86 instruction set is particularly complex? This is actually a characteristic of CISC, using complex instruction format, sacrificing the development cost of hardware, but also to make a single instruction can do more things, so as to increase the density of code, reduce the size of the program. As time progressed, architects realized that the complex control logic in CISC was not conducive to improving processor performance, so RISC was born. The purpose of RISC is simplicity, fewer instructions, fixed instruction length, and uniform instruction format, which is similar to the KISS rule. There is a short article comparing RISC and CISC at [here](http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc).
>
> Also we recommend [this article](http://blog.sciencenet.cn/blog-414166-763326.html), which tells the story of the birth of the RISC world and its integration with the CISC world, giving a sense of the RISC is a milestone in the evolution of computer architectures.

<!-- 如果你非常幸运地选择了riscv32, 你会发现目前只需要阅读很少部分的手册内容就可以了:
在PA中, riscv32的客户程序只会由RV32I和RV32M两类指令组成.
这得益于RISC-V指令集的设计理念 - 模块化. -->
If you're lucky enough to choose riscv32, you'll find that you only need to read a very small portion of the manual at this point: in PA, riscv32's client program consists of only two types of instructions, RV32I and RV32M. This is due to the design concept of the RISC-V instruction set - modularity.

<!-- > #### comment::RISC-V - 一款设计精巧的指令集
> RISC-V是一款非常年轻的指令集 - 第一版RISC-V是在2011年5月由UC Berkeley的研究团队提出的,
> 至今已经风靡全球. 开放性是RISC-V的最大卖点, 就连ARM和MIPS也都为之震撼, 甚至还因竞争关系而互撕...
> [这篇文章][riscv bao]叙述了RISC-V的理念以及成长的一些历史.
>
> 当然, 这些和处于教学领域的PA其实没太大关系. 关键是
> * RISC-V真的很简单.
> * 简单之余, 还有非常多对程序运行深思熟虑的考量.
>   如果你阅读RISC-V的手册, 你就会发现里面阐述了非常多设计的推敲和取舍.
>   另外David Patterson教授(因推广RISC而获得2018年的图灵奖, 可谓体系结构领域的一代宗师)
>   还为RISC-V的推广编写了一本入门书籍[The RISC-V Reader][riscv reader],
>   书中从系统的角度叙述了RISC-V大量的设计原则, 并与现有指令集进行对比, 非常值得一读.
>   中科院计算所的三位研究生为这本书编写了[中文翻译的版本][riscv reader chinese]
>   (其中一位也算是你们的直系师兄了), 不过由于这本书并没有跟进RISC-V官方手册的最新内容,
>   而且书中有不少笔误(欢迎到[相应的github repo][riscv reader chinese github]中提issue),
>   我们还是建议你阅读RISC-V的官方手册.

[riscv bao]: http://blog.sciencenet.cn/blog-414166-1089206.html
[riscv reader]: http://www.riscvbook.com
[riscv reader chinese]: http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf
[riscv reader chinese github]: https://github.com/Lingrui98/RISC-V-book -->

> #### comment::RISC-V - A well-designed instruction set
>
> RISC-V is a very young instruction set - the first version of RISC-V was proposed by a team of researchers at UC Berkeley in May 2011, and has since taken the world by storm. Openness is RISC-V's biggest selling point, and even ARM and MIPS have been shocked by it, and even try to tearing each other apart for the competition... [This article](http://blog.sciencenet.cn/blog-414166-1089206.html) describes the concept of RISC-V and some of the history of its growth.
>
> Of course, this is not really relevant to PAs in the teaching field. The point is.
>
> * RISC-V is really simple.
> * And while it is simple, there are a lot of thoughtful considerations about how the program should run. If you read the RISC-V manual, you'll see that there are a lot of design choices and trade-offs. In addition, Prof. David Patterson (who won the 2018 Turing Award for promoting RISC, and is considered to be one of the great masters in the field of architecture) has also written an introductory book for the promotion of RISC-V, The RISC-V Reader, which describes a large number of RISC-V design principles from a systematic point of view and compares them with the existing instruction set, which is well worth a read. The RISC-V Reader is an introductory book. Three graduate students at the Institute of Computing, Chinese Academy of Sciences, have written a Chinese translation of this book (one of them is also your direct senior), but since this book does not follow the latest contents of the official RISC-V manual, and there are a lot of clerical errors in the book (feel free to raise an issue in the corresponding github repo), we still recommend that you read the official RISC-V manual.

<!-- ## RTFSC(2) -->
## RTFSC(2)

<!-- 理解了上一小节的YEMU如何执行指令之后, 你就会对模拟器的框架有一个基本的认识了.
NEMU要模拟一个真实的ISA, 因此代码要比YEMU复杂得多, 但其中蕴含的基本原理是和YEMU相同的.
下面我们来介绍NEMU的框架代码如何实现指令的执行. -->

After understanding how YEMU executes instructions in the previous subsection, you will have a basic understanding of the emulator's framework. NEMU has to simulate a real ISA, so the code is much more complex than YEMU, but the underlying principles are the same as YEMU. Below we describe how NEMU's framework code implements the execution of commands.

<!-- 在RTFSC的过程中, 你会遇到用于抽象ISA差异的大部分API,
因此我们建议你先阅读[这个页面](nemu-isa-api.md)来对这些API的功能进行基本的了解,
将来在代码中遇到它们的时候可以进行查阅. -->

During the course of RTFSC, you will encounter most of the APIs used to abstract ISA differences, so we recommend that you read [this page](nemu-isa-api.html) to get a basic understanding of what these APIs do, so that you can refer to them when you encounter them in your code in the future.

<!-- 我们在PA1中提到: -->

We mentioned in PA1.

<!--
> `cpu_exec()`又会调用`execute()`, 后者模拟了CPU的工作方式: 不断执行指令.
> 具体地, 代码将在一个for循环中不断调用`exec_once()`函数,
> 这个函数的功能就是我们在上一小节中介绍的内容: 让CPU执行当前PC指向的一条指令, 然后更新PC. -->

> `cpu_exec()` in turn calls `execute()`, which mimics the way the CPU works: executing instructions over and over again. Specifically, the code calls the `exec_once()` function in a for loop, which does what we described in the previous subsection: it tells the CPU to execute an instruction pointed to by the current PC, and then update the PC.

<!-- 具体地, `exec_once()`接受一个`Decode`类型的结构体指针`s`,
这个结构体用于存放在执行一条指令过程中所需的信息, 包括指令的PC, 下一条指令的PC等.
还有一些信息是ISA相关的, NEMU用一个结构类型`ISADecodeInfo`来对这些信息进行抽象,
具体的定义在`nemu/src/isa/$ISA/include/isa-def.h`中.
`exec_once()`会先把当前的PC保存到`s`的成员`pc`和`snpc`中,
其中`s->pc`就是当前指令的PC, 而`s->snpc`则是下一条指令的PC,
这里的`snpc`是"static next PC"的意思. -->

Specifically, `exec_once()` accepts a pointer `s` to a structure of type `Decode`, which is used to hold information needed during the execution of an instruction, including the current PC of the instruction, the PC of the next instruction, etc. There is also some information that is ISA-related, which NEMU abstracts with a structure of type `ISADecodeInfo`, defined in `nemu/src/isa/$ISA/include/isa-def.h`. `exec_once()` first saves the current PC to members `pc` and `snpc` of `s`, where `s->pc` is the PC of the current instruction and `s->snpc` is the PC of the next instruction, where `snpc` means "static next PC".

<!-- 然后代码会调用`isa_exec_once()`函数(在`nemu/src/isa/$ISA/inst.c`中定义),
这是因为执行指令的具体过程是和ISA相关的, 在这里我们先不深究`isa_exec_once()`的细节.
但可以说明的是, 它会随着取指的过程修改`s->snpc`的值,
使得从`isa_exec_once()`返回后`s->snpc`正好为下一条指令的PC.
接下来代码将会通过`s->dnpc`来更新PC, 这里的`dnpc`是"dynamic next PC"的意思.
关于`snpc`和`dnpc`的区别, 我们会在下文进行说明. -->

The code then calls the `isa_exec_once()` function (defined in `nemu/src/isa/$ISA/inst.c`), because the exact process of executing the instruction is ISA-related, so we won't delve into the details of `isa_exec_once()` here. What is clear is that it modifies the value of `s->snpc` as it fetches the instruction, so that `s->snpc` will be the PC for the next instruction when it returns from `isa_exec_once()`. The code will then update the PC with `s->dnpc`, where `dnpc` stands for "dynamic next PC". The difference between `snpc` and `dnpc` is explained below.

<!-- 忽略`exec_once()`中剩下与trace相关的代码, 我们就返回到`execute()`中.
代码会对一个用于记录客户指令的计数器加1, 然后进行一些trace和difftest相关的操作(此时先忽略),
然后检查NEMU的状态是否为`NEMU_RUNNING`, 若是, 则继续执行下一条指令, 否则则退出执行指令的循环. -->

Ignoring the rest of the trace-related code in `exec_once()`, we return to `execute()`. The code adds 1 to a counter used to record client instructions, then does some trace and difftest related operations (which we ignore at this point), and then checks to see if the NEMU status is `NEMU_RUNNING`, if it is, it continues with the next instruction, otherwise it exits the loop of executing instructions.

<!--
事实上, `exec_once()`函数覆盖了指令周期的所有阶段: 取指, 译码, 执行, 更新PC,
接下来我们来看看NEMU是如何实现指令周期的每一个阶段的. -->

In fact, the `exec_once()` function covers all phases of the instruction cycle: fetch, decode, execute, and update the PC, so let's take a look at how the NEMU implements each phase of the instruction cycle.

<!-- ### 取指(instruction fetch, IF) -->
### instruction fetch, IF

<!-- `isa_exec_once()`做的第一件事情就是取指令.
在NEMU中, 有一个函数`inst_fetch()`(在`nemu/include/cpu/ifetch.h`中定义)专门负责取指令的工作.
`inst_fetch()`最终会根据参数`len`来调用`vaddr_ifetch()`(在`nemu/src/memory/vaddr.c`中定义),
而目前`vaddr_ifetch()`又会通过`paddr_read()`来访问物理内存中的内容.
因此, 取指操作的本质只不过就是一次内存的访问而已. -->

The first thing `isa_exec_once()` does is fetch instructions. In NEMU, there is a function `inst_fetch()` (defined in `nemu/include/cpu/ifetch.h`) that does this. `inst_fetch()` ultimately calls `vaddr_ifetch()` (defined in `nemu/src/memory/vaddr.c`) with the parameter `len`, and `vaddr_ifetch()` accesses the contents of physical memory via `paddr_read()`. Thus, an instruction fetch operation is nothing more than a memory access.

<!-- `isa_exec_once()`在调用`inst_fetch()`的时候传入了`s->snpc`的地址,
因此`inst_fetch()`最后还会根据`len`来更新`s->snpc`, 从而让`s->snpc`指向下一条指令. -->

`isa_exec_once()` passes in the address of `s->snpc` when calling `inst_fetch()`, so `inst_fetch()` ends up updating `s->snpc` with `len`, which points `s->snpc` to the next instruction.

<!-- ### 译码(instruction decode, ID) -->
### instruction decode, ID

<!-- 接下来代码会进入`decode_exec()`函数, 它首先进行的是译码相关的操作.
译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的`opcode`来决定的.
不同ISA的`opcode`会出现在指令的不同位置, 我们只需要根据指令的编码格式,
从取出的指令中识别出相应的`opcode`即可. -->

The code then goes to the `decode_exec()` function, which first performs decoding-related operations. The purpose of decoding is to get the operation and the oprand of the instruction, which is determined by looking at the `opcode` of the instruction. The `opcode` of different ISAs can be found in different places in the instruction, so we just need to recognize the corresponding `opcode` from the instruction according to the encoding format of the instruction.

<!--
和YEMU相比, NEMU使用一种抽象层次更高的译码方式: 模式匹配,
NEMU可以通过一个模式字符串来指定指令中`opcode`, 例如在riscv32中有如下模式: -->

Compared with YEMU, NEMU uses a higher level of abstraction: pattern matching, NEMU can specify the `opcode` in an instruction by a pattern string, for example, in riscv32 there is the following pattern: INSTPAT_START(), INSTPAT_START(), INSTPAT_START(), INSTPAT_START().

```c
INSTPAT_START();
INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U, R(rd) = s->pc + imm);
// ...
INSTPAT_END();
```

<!-- 其中`INSTPAT`(意思是instruction pattern)是一个宏(在`nemu/include/cpu/decode.h`中定义),
它用于定义一条模式匹配规则. 其格式如下: -->

Where `INSTPAT` (shorthand for instruction pattern) is a macro (defined in `nemu/include/cpu/decode.h`), which is used to define a pattern-matching rule. The format is as follows.

<!-- ```
INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);
``` -->

```
INSTPAT(pattern string, instruction name, instruction type, instruction execution operation);
```

<!-- `模式字符串`中只允许出现4种字符:
* `0`表示相应的位只能匹配`0`
* `1`表示相应的位只能匹配`1`
* `?`表示相应的位可以匹配`0`或`1`
* 空格是分隔符, 只用于提升模式字符串的可读性, 不参与匹配 -->

Only four characters are allowed in the `pattern string`.

* `0`` means that the corresponding bit can only match `0`
* `1` means that the corresponding bit can only match `1`
* `? ` means the corresponding bit can match either `0` or `1`
* Space is a separator, only used to improve the readability of the pattern string, not involved in matching.

<!-- `指令名称`在代码中仅当注释使用, 不参与宏展开;
`指令类型`用于后续译码过程; 而`指令执行操作`则是通过C代码来模拟指令执行的真正行为. -->

The `instruction name' is used only as a comment in the code and does not participate in macro expansion; the `instruction type' is used in the subsequent decoding process; and the `instruction execution operation' is the C code that simulates the real behavior of the instruction execution.

<!-- 此外, `nemu/include/cpu/decode.h`中还定义了宏`INSTPAT_START`和`INSTPAT_END`.
`INSTPAT`又使用了另外两个宏`INSTPAT_INST`和`INSTPAT_MATCH`, 它们在`nemu/src/isa/$ISA/inst.c`中定义.
对上述代码进行宏展开并简单整理代码之后, 最后将会得到: -->

In addition, the macros `INSTPAT_START` and `INSTPAT_END` are defined in `nemu/include/cpu/decode.h`. `INSTPAT` uses two other macros, `INSTPAT_INST` and `INSTPAT_MATCH`, which are defined in `nemu/src/isa/$ISA/inst.c`. After expanding the above code with macros and simply organizing the code, you will end up with.
```c
{ const void ** __instpat_end = &&__instpat_end_;
do {
  uint64_t key, mask, shift;
  pattern_decode("??????? ????? ????? ??? ????? 00101 11", 38, &key, &mask, &shift);
  if ((((uint64_t)s->isa.inst.val >> shift) & mask) == key) {
    {
      decode_operand(s, &rd, &src1, &src2, &imm, TYPE_U);
      R(rd) = s->pc + imm;
    }
    goto *(__instpat_end);
  }
} while (0);
// ...
__instpat_end_: ; }
```
<!-- 上述代码中的`&&__instpat_end_`使用了GCC提供的[标签地址][label address]扩展功能,
`goto`语句将会跳转到最后的`__instpat_end_`标签.
此外, `pattern_decode()`函数在`nemu/include/cpu/decode.h`中定义,
它用于将模式字符串转换成3个整型变量.

[label address]: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html -->

The `&&__instpat_end_` in the above code uses the [label as values](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html) extension provided by GCC, and the `goto` statement will jump to the last `__instpat_end_` label. In addition, the `pattern_decode()` function is defined in `nemu/include/cpu/decode.h` and is used to convert pattern strings into three integer variables.

<!-- `pattern_decode()`函数将模式字符串中的`0`和`1`抽取到整型变量`key`中,
`mask`表示`key`的掩码, 而`shift`则表示`opcode`距离最低位的比特数量, 用于帮助编译器进行优化.
具体地, 上述例子中: -->

The `pattern_decode()` function extracts the `0` and `1` from the pattern string into the integer variable `key`, with `mask` indicating the mask of the `key`, and `shift` indicating the number of bits away from the lowest bit of the `opcode`, to aid in the optimization by the compiler. Specifically, in the above example.

```c
key   = 0x17;
mask  = 0x7f;
shift = 0;
```

<!-- 考虑PA1中介绍的内建客户程序中的如下指令: -->

Consider the following instruction from the built-in client program introduced in PA1.

```
0x00000297   auipc t0,0
```

<!-- NEMU取指令的时候会把指令记录到`s->isa.inst.val`中, 此时指令满足上述宏展开的`if`语句,
表示匹配到`auipc`指令的编码, 因此将会进行进一步的译码操作. -->

When NEMU fetches the instruction, it will record the instruction into `s->isa.inst.val`, and then the `if` statement in the above macro expansion evals to true, which means that it matches the opcode of the `auipc` instruction, and therefore further decoding operation will be performed.

<!-- 刚才我们只知道了指令的具体操作(比如`auipc`是将当前PC值与立即数相加并写入寄存器),
但我们还是不知道操作对象(比如立即数是多少, 写入到哪个寄存器).
为了解决这个问题, 代码需要进行进一步的译码工作,
这是通过调用`decode_operand()`函数来完成的.
这个函数将会根据传入的指令类型`type`来进行操作数的译码,
译码结果将记录到函数参数`rd`, `src1`, `src2`和`imm`中,
它们分别代表目的操作数的寄存器号码, 两个源操作数和立即数. -->

We only know what the instruction does (e.g. `auipc` adds the current PC value to the immediate number and writes it to a register), but we still don't know what is the oprand (e.g. what the immediate number is, and what register it writes to). To solve this problem, the code needs to be decoded further, which is done by calling the `decode_operand()` function. This function will decode the operands according to the parameter `type` (instruction type), and the result will be recorded in the parameters `rd`, `src1`, `src2`, and `imm`, which represent the register number of the destination operand, the two source operands, and the immediate number, respectively.

<!-- 我们会发现, 类似寄存器和立即数这些操作数, 其实是非常常见的操作数类型.
为了进一步实现操作数译码和指令译码的解耦, 我们对这些操作数的译码进行了抽象封装:
* 框架代码定义了`src1R()`和`src2R()`两个辅助宏, 用于寄存器的读取结果记录到相应的操作数变量中
* 框架代码还定义了`immI`等辅助宏, 用于从指令中抽取出立即数 -->

We realize that operands such as registers and immediate numbers are very common types of operands. In order to further decouple operand decoding from instruction decoding, we have abstracted and encapsulated the decoding of these operands.

* The framework code defines two helper macros, `src1R()` and `src2R()`, which are used to pass the results of register reads to the corresponding operand variables.
* The framework code also defines helper macros such as `immI`, which are used to extract immediate numbers from instructions.

<!-- 有了这些辅助宏, 我们就可以用它们来方便地编写`decode_operand()`了,
例如RISC-V中I型指令的译码过程可以通过如下代码实现: -->

With these helper macros, we can use them to write `decode_operand()` conveniently, for example, the decoding process of type-I instructions in RISC-V can be realized by the following code:

```c
case TYPE_I: src1R(); immI(); break;
```

<!-- 另外补充几点说明:
* `decode_operand`中用到了宏`BITS`和`SEXT`, 它们均在`nemu/include/macro.h`中定义,
分别用于位抽取和符号扩展
* `decode_operand`会首先统一对目标操作数进行寄存器操作数的译码, 即调用`*rd = BITS(i, 11, 7)`,
不同的指令类型可以视情况使用`rd`
* 在模式匹配过程的最后有一条`inv`的规则, 表示"若前面所有的模式匹配规则都无法成功匹配,
则将该指令视为非法指令 -->

A couple of additional notes.

* `decode_operand` uses the macros `BITS` and `SEXT`, which are defined in `nemu/include/macro.h` and are used for bit extraction and symbol expansion, respectively.
* `decode_operand` will first decode the destination operand through register operands decoding, i.e. call `*rd = BITS(i, 11, 7)`, and `rd` can be used for different types of instructions depending on the situation.
* At the end of the pattern matching process, there is an `inv` rule, which means that "if all the previous pattern matching rules fail to match successfully, then the instruction is considered illegal".

<!-- > #### comment::x86的变长指令
> 由于CISC指令变长的特性, x86指令长度和指令形式需要一边取指一边译码来确定,
> 而不像RISC指令集那样可以泾渭分明地处理取指和译码阶段,
> 因此你会在x86的译码过程中看到`inst_fetch()`的操作. -->

> #### comment::Variable-length instructions for x86
>
> Due to the variable-length nature of CISC instructions, x86 instruction lengths and instruction forms need to be determined by fetching and decoding at the same time, unlike the RISC instruction set which handles the fetch and decode phases in a clear-cut manner, so you'll see `inst_fetch()` operations in the x86 decoding process.

<!-- > #### question::立即数背后的故事
> 框架代码通过`inst_fetch()`函数进行取指, 别看这里就这么一行代码,
> 其实背后隐藏着针对[字节序][endianness]的慎重考虑.
> 大部分同学的主机都是x86小端机, 当你使用高级语言或者汇编语言写了一个32位常数`0x1234`的时候,
> 在生成的二进制代码中, 这个常数对应的字节序列如下(假设这个常数在内存中的起始地址是x):
> ```
> x   x+1  x+2  x+3
> +----+----+----+----+
> | 34 | 12 | 00 | 00 |
> +----+----+----+----+
> ```
> 而大多数PC机都是小端架构(我们相信没有同学会使用IBM大型机来做PA), 当NEMU运行的时候,
> ```c
> imm = inst_fetch(pc, 4);
> ```
> 这行代码会将`34 12 00 00`这个字节序列原封不动地从内存读入`imm`变量中,
> 主机的CPU会按照小端方式来解释这一字节序列, 于是会得到`0x1234`, 符合我们的预期结果.
>
> Motorola 68k系列的处理器都是大端架构的.
> 现在问题来了, 考虑以下两种情况:
> * 假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)
> * 假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中
>
> 在这两种情况下, 你需要注意些什么问题?
> 为什么会产生这些问题? 怎么解决它们?
>
> 事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题.
> 我们在这里把问题统一抛出来, 以后就不再单独讨论了.

[endianness]: http://en.wikipedia.org/wiki/Endianness -->

> #### question::The Story Behind Immediate Numbers
>
> Framework code through the `inst_fetch()` function to fetch the instructions, even this is only 1 line of code, in fact, behind the scenes, it hides the careful consideration for [endianness](http://en.wikipedia.org/wiki/Endianness). Most of the students' hosts are x86 little-endian machines, when you use high-level language or assembly language to write a 32-bit constant `0x1234`, in the generated binary code, the constant corresponds to the byte sequence as follows (assuming that the constant's starting address in memory is x).
> ```
> x   x+1  x+2  x+3
> +----+----+----+----+
> | 34 | 12 | 00 | 00 |
> +----+----+----+----+
> ```
> Whereas most PCs are little-endian architectures (we're sure no students will use an IBM mainframe for PA), when NEMU is running
> ```c
> imm = inst_fetch(pc, 4);
> ```
> This line of code reads the byte sequence `34 12 00 00` from memory into the `imm` variable as is, and the host CPU interprets this byte sequence in the little-endian fashion, resulting in `0x1234`, which is what we expect.
>
> The processors in the Motorola 68k series are all big-endian architecture. Now the question arises, consider the following two scenarios.
>
> * Suppose we need to run NEMU on a Motorola 68k machine (compiling the NEMU source code into Motorola 68k machine code).
> * Suppose we need to add Motorola 68k as a new ISA to NEMU.
>
> In those cases, what problems do you need to be aware of? Why do these problems occur? How to solve them?
>
> The fact is that it is not only the immediate number accesses, but also any memory accesses longer than 1 byte need to be considered similarly. We're going to throw the problems out here, and not discuss them separately in the future.

<!-- > #### question::立即数背后的故事(2)
> mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样,
> 把C代码中的32位常数直接编码到一条指令中.
> 思考一下, mips32和riscv32应该如何解决这个问题? -->

> #### question::The Story Behind Immediate Numbers (2)
>
> The instruction lengths of mips32 and riscv32 are only 32 bits, so they can't encode 32-bit constants from C code directly into a single instruction like x86 can. Think about it, how should mips32 and riscv32 solve this problem?

<!-- > #### hint::我要被宏定义绕晕了, 怎么办?
> 为了理解一个宏的语义, 你可能会尝试手动对它进行宏展开, 但你可能会碰到如下困难:
> * 宏嵌套的次数越多, 理解越困难
> * 一些拼接宏会影响编辑器的代码跳转功能
>
> 事实上, 为了进行宏展开, 你并不需要手动去进行操作, 因为肯定有工具能做这件事:
> 我们只需要让GCC把编译预处理的结果输出出来, 就可以看到宏展开的结果了.
> 有了宏展开的结果, 你就可以快速理解展开之后的语义,
> 然后反过来理解相应的宏是如何一步步被展开的了.
>
> 当然, 最方便的做法是让GCC编译NEMU的时候顺便输出预处理的结果,
> 如果你对Makefile的组织有一定的认识, 这件事当然也难不倒你了. -->

> #### hint::I'm getting confused by macro definitions, what should I do?
>
> In order to understand the semantics of a macro, you may try to expand it manually, but you may encounter the following difficulties.
>
> * The more macros are nested, the more difficult it is to understand them.
> * Some Token-pasting (##) macros can interfere with the editor's go to definition functionality.
>
> In fact, you don't need to do this manually in order to expand macros, because there are tools that can do it: all we need to do is to let GCC output the results of the preprocessing, and then we can see the result of the macro expansion. With the result of the macro expansion, you can quickly understand the semantics of the expansion, and in turn understand how the macro was expanded step-by-step.
>
> Of course, the most convenient way to do this is to let GCC compile NEMU and output the preprocessing results at the same time, which is not difficult if you have some knowledge of the Makefiles.

<!-- ### 执行(execute, EX) -->
### execute, EX

<!-- 译码阶段结束之后, 代码将会执行模式匹配规则中指定的`指令执行操作`,
这部分操作会用到译码的结果, 并通过C代码来模拟指令执行的真正行为.
例如对于`auipc`指令, 由于译码阶段已经把U型立即数记录到操作数`imm`中了,
我们只需要通过`R(rd) = s->pc + imm`将立即数与当前PC值相加并写入目标寄存器中, 这样就完成了指令的执行. -->

After the decoding phase, the code will execute the `instruction execution operation` specified in the pattern matching rule, which will use the result of decoding and simulate the real behavior of the instruction execution by C code. For example, for the `auipc` instruction, since the U-type immediate number has already been recorded into the operand `imm` during the decoding phase, we only need to add the immediate number and the current PC value by `R(rd) = s->pc + imm` and write it to the target register, and then the execution of the instruction will be completed.

<!-- 指令执行的阶段结束之后, `decode_exec()`函数将会返回`0`, 并一路返回到`exec_once()`函数中.
不过目前代码并没有使用这个返回值, 因此可以忽略它. -->

At the end of the instruction execution phase, the `decode_exec()` function returns `0`, and goes all the way back to the `exec_once()` function. However, the current code does not use this return value, so it can be ignored.

<!-- ### 更新PC -->
### Update PC

<!-- 最后是更新PC. 更新PC的操作非常简单, 只需要把`s->dnpc`赋值给`cpu.pc`即可.
我们之前提到了`snpc`和`dnpc`, 现在来说明一下它们的区别. -->

Finally, updating the PC. Updating the PC is very simple, just assign `s->dnpc` to `cpu.pc`. We mentioned `snpc` and `dnpc` earlier, so let's explain the difference now.

<!-- > #### hint::静态指令和动态指令
> 在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令.
ysyx> 例如对于以下指令序列
> ```
> 100: jmp 102
> 101: add
> 102: xor
> ```
> `jmp`指令的下一条静态指令是`add`指令, 而下一条动态指令则是`xor`指令. -->

> #### hint::Static and dynamic instructions
>
> In the field of program analysis, static instructions are the instructions in the program code, and dynamic instructions are the instructions during program execution. For example, for the following sequence of instructions
> ```
> 100: jmp 102
> 101: add
> 102: xor
> ```
> The next static instruction for the `jmp` instruction is the `add` instruction, and the next dynamic instruction is the `xor` instruction.

<!-- 有了静态指令和动态指令这两个概念之后, 我们就可以说明`snpc`和`dnpc`的区别了:
`snpc`是下一条静态指令, 而`dnpc`是下一条动态指令.
对于顺序执行的指令, 它们的`snpc`和`dnpc`是一样的;
但对于跳转指令, `snpc`和`dnpc`就会有所不同, `dnpc`应该指向跳转目标的指令.
显然, 我们应该使用`s->dnpc`来更新PC, 并且在指令执行的过程中正确地维护`s->dnpc`. -->

With the concepts of static and dynamic instructions, we can explain the difference between `snpc` and `dnpc`: `snpc` is the next static instruction, while `dnpc` is the next dynamic instruction. For sequential instructions, their `snpc` and `dnpc` are the same; but for jump instructions, `snpc` and `dnpc` are different, and `dnpc` should point to the instruction that is the target of the jump. Obviously, we should use `s->dnpc` to update the PC, and maintain `s->dnpc` correctly during instruction execution.

---

<!-- 上文已经把一条指令在NEMU中执行的流程进行了大概的介绍,
但还有少量的细节没有完全覆盖(例如x86的指令组译码表), 这些细节就交给你来去尝试理解啦. -->

The flow of an instruction execution in the NEMU has been described above, but there are a few details that have not been fully covered (e.g., the x86 instruction set decoder table), so it is up to you to try to understand these details.

<!--
不过为了特别照顾选择x86的同学, 我们还是准备了[一个例子](exec.md)来RTFSC.
-->

<!-- > #### caution::驾驭项目, 而不是被项目驾驭
> 你和一个项目的关系会经历4个阶段:
> 1. 被驾驭: 你对它一无所知
> 1. 一知半解: 你对其中的主要模块和功能有了基本的了解
> 1. 驾轻就熟: 你对整个项目的细节都了如指掌
> 1. 为你所用: 你可以随心所欲地在项目中添加你认为有用的功能
>
> 在PA中, 达到第二个阶段的主要手段是阅读讲义和代码,
> 达到第三个阶段的主要手段是独立完成实验内容和独立调试.
> 至于要达到第四个阶段, 就要靠你的主观能动性了: 代码还有哪里做得不够好?
> 怎么样才算是够好? 应该怎么做才能达到这个目标?
>
> 你毕业后到了工业界或学术界, 就会发现真实的项目也都是这样:
> 1. 刚接触一个新项目, 不知道如何下手
> 1. RTFM, RTFSC, 大致明白项目组织结构和基本的工作流程
> 1. 运行项目的时候发现有非预期行为(可能是配置错误或环境错误,
> 可能是和已有项目对接出错, 也可能是项目自身的bug), 然后调试.
> 在调试过程中, 对这些模块的理解会逐渐变得清晰.
> 1. 哪天需要你在项目中添加一个新功能, 你会发现自己其实可以胜任.
>
> 这说明了: <font color=red>如果你一遇到bug就找大神帮你调试,
> 你失去的机会和能力会比你想象的多得多</font>. -->

> #### caution::Drive the project, not be driven by the project.
>
> Your relationship with a program will go through 4 stages:
>
> 1. Being driven: you don't know anything about it.
> 2. Understood: you have a basic understanding of the main modules and functions.
> 3. Fluent: you know most of the details of the entire project.
> 4. Mastered: You can add any functionality you want to the project.
>
> In PA, the main way to reach the second stage is to read the handouts and the code, and the main way to reach the third stage is to complete the experiments and debug them independently. To reach the fourth stage, it is up to you: what is not good enough in the code? What is good enough? What should be done to achieve this goal?
>
> When you graduate and go into industry or academia, you'll find that real projects are all like this.
>
> 1. Just on board with a new project, don't know how to start.
> 2. RTFM, RTFSC, roughly understand the project organizational structure and basic workflow
> 3. When you run the project, you find that there is unintended behavior (maybe a configuration error or environment error, may be an error in interfacing with an existing project, or may be the project's own bugs), and then debug it. In the debugging process, the understanding of these modules will gradually become clear. 4.
> 4. One day you need to add a new feature in the project, you will realize that you can actually handle it.
>
> What this shows is that <font color=red> if you go to the experts to help you debug a bug everytime you encounter it, you're missing out on a lot more opportunities and capabilities than you might think.</font>

<!--
> #### comment::拦截客户程序访存越界的非法行为
> 你将来很可能会遇到客户程序访存越界的错误, NEMU的框架代码一旦检测到这一行为就会直接panic.
> 这一行为的检测已经极大地帮助你发现代码的问题了,
> 想象一下, 如果NEMU并未拦截这一error, 你可能会看到怎么样的failure?
-->

<!-- ### 结构化程序设计 -->
### Structured program design

<!-- 我们刚才介绍了译码过程中的一些辅助用的函数和宏, 它们的引入都是为了实现代码的解偶, 提升可维护性.
如果指令集越复杂, 指令之间的共性特征就越多, 以x86为例:
* 对于同一条指令的不同形式, 它们的执行阶段是相同的.
例如`add_I2E`和`add_E2G`等, 它们的执行阶段都是把两个操作数相加, 把结果存入目的操作数.
* 对于不同指令的同一种形式, 它们的译码阶段是相同的.
例如`add_I2E`和`sub_I2E`等, 它们的译码阶段都是识别出一个立即数和一个`E`操作数.
* 对于同一条指令同一种形式的不同操作数宽度, 它们的译码阶段和执行阶段都是非常类似的.
例如`add_I2E_b`, `add_I2E_w`和`add_I2E_l`,
它们都是识别出一个立即数和一个`E`操作数, 然后把相加的结果存入`E`操作数. -->

We have just introduced some utility functions and macros for the decoding process, which were introduced for the purpose of decoupling and improving maintainability. If the instruction set is more complex, there are more common features between instructions, for example, in the case of x86:

* For different forms of the same instruction, the execution phase is the same. For example, `add_I2E` and `add_E2G` both add two operands and store the result in the destination operand.
* For the same form of different instructions, the decoding phase is the same. For example, `add_I2E` and `sub_I2E` both decode an immediate number and an `E` operand in their decoding phase.
* For different operand widths of the same form of the same instruction, the decoding and execution phases are very similar. For example, `add_I2E_b`, `add_I2E_w`, and `add_I2E_l`, all recognize an immediate number and an `E` operand, and then store the result of the addition into the `E` operand.

<!-- 这意味着, 如果独立实现每条指令不同形式不同操作数宽度的译码和执行过程, 将会引入大量重复的代码.
需要修改的时候, 所有相关代码都要分别修改, 遗漏了某一处就会造成bug, 工程维护的难度急速上升. -->

This means that if the decoding and execution process is implemented independently for each instruction with different forms and operand widths, a lot of duplicated code will be introduced. When modifications are needed, all the related code has to be modified separately, and missing a certain place will cause bugs, and the difficulty of project maintenance will increase rapidly. This is essentially another form of ODR (one definition rule) rule. Where you reuse code as much as possible so whenever you need to change something you only need to change it in a single place.

<!-- > #### comment::来体会一下
> 过去有同学通过如下代码实现`isa_reg_str2val()`函数:
> ```c
> if (strcmp(s, "$0") == 0)
>   return cpu.gpr[0]._64;
> else if (strcmp(s, "ra") == 0)
>   return cpu.gpr[1]._64;
> else if (strcmp(s, "sp") == 0)
>   return cpu.gpr[2]._64;
> else if (strcmp(s, "gp") == 0)
>   return cpu.gpr[3]._64;
> else if (strcmp(s, "tp") == 0)
>   return cpu.gpr[4]._64;
> else if (strcmp(s, "t0") == 0)
>   return cpu.gpr[5]._64;
> else if (strcmp(s, "t1") == 0)
>   return cpu.gpr[6]._64;
> else if (strcmp(s, "s2") == 0)
>   return cpu.gpr[7]._64;
> else if (strcmp(s, "s0") == 0)
>   return cpu.gpr[8]._64;
> else if (strcmp(s, "s1") == 0)
>   return cpu.gpr[9]._64;
> else if (strcmp(s, "a0") == 0)
>   return cpu.gpr[10]._64;
> else if (strcmp(s, "a1") == 0)
>   return cpu.gpr[11]._64;
> else if (strcmp(s, "a2") == 0)
>   return cpu.gpr[12]._64;
> else if (strcmp(s, "a3") == 0)
>   return cpu.gpr[13]._64;
> else if (strcmp(s, "a4") == 0)
>   return cpu.gpr[14]._64;
> else if (strcmp(s, "a5") == 0)
>   return cpu.gpr[15]._64;
> else if (strcmp(s, "a6") == 0)
>   return cpu.gpr[16]._64;
> else if (strcmp(s, "a7") == 0)
>   return cpu.gpr[17]._64;
> else if (strcmp(s, "s2") == 0)
>   return cpu.gpr[18]._64;
> else if (strcmp(s, "s3") == 0)
>   return cpu.gpr[19]._64;
> else if (strcmp(s, "s4") == 0)
>   return cpu.gpr[20]._64;
> else if (strcmp(s, "s5") == 0)
>   return cpu.gpr[21]._64;
> else if (strcmp(s, "s6") == 0)
>   return cpu.gpr[22]._64;
> else if (strcmp(s, "s7") == 0)
>   return cpu.gpr[23]._64;
> else if (strcmp(s, "s8") == 0)
>   return cpu.gpr[24]._64;
> else if (strcmp(s, "s8") == 0)
>   return cpu.gpr[25]._64;
> else if (strcmp(s, "s10") == 0)
>   return cpu.gpr[26]._64;
> else if (strcmp(s, "t2") == 0)
>   return cpu.gpr[27]._64;
> else if (strcmp(s, "t3") == 0)
>   return cpu.gpr[28]._64;
> else if (strcmp(s, "t4") == 0)
>   return cpu.gpr[29]._64;
> else if (strcmp(s, "t5") == 0)
>   return cpu.gpr[30]._64;
> else if (strcmp(s, "t5") == 0)
>   return cpu.gpr[31]._64;
> ```
> 你应该能想象到这位同学是如何编写上述代码的.
> 现在问题来了, 你能快速检查上述代码是否正确吗?
>
> 更多地, 如果你的项目中有很多这样的代码, 你还愿意仔细地读一读它们吗? -->

> #### comment::Let's experience this.
>
> In the past, a student implemented the `isa_reg_str2val()` function with the following code.
> ```c
> if (strcmp(s, "$0") == 0)
>   return cpu.gpr[0]._64;
> else if (strcmp(s, "ra") == 0)
>   return cpu.gpr[1]._64;
> else if (strcmp(s, "sp") == 0)
>   return cpu.gpr[2]._64;
> else if (strcmp(s, "gp") == 0)
>   return cpu.gpr[3]._64;
> else if (strcmp(s, "tp") == 0)
>   return cpu.gpr[4]._64;
> else if (strcmp(s, "t0") == 0)
>   return cpu.gpr[5]._64;
> else if (strcmp(s, "t1") == 0)
>   return cpu.gpr[6]._64;
> else if (strcmp(s, "s2") == 0)
>   return cpu.gpr[7]._64;
> else if (strcmp(s, "s0") == 0)
>   return cpu.gpr[8]._64;
> else if (strcmp(s, "s1") == 0)
>   return cpu.gpr[9]._64;
> else if (strcmp(s, "a0") == 0)
>   return cpu.gpr[10]._64;
> else if (strcmp(s, "a1") == 0)
>   return cpu.gpr[11]._64;
> else if (strcmp(s, "a2") == 0)
>   return cpu.gpr[12]._64;
> else if (strcmp(s, "a3") == 0)
>   return cpu.gpr[13]._64;
> else if (strcmp(s, "a4") == 0)
>   return cpu.gpr[14]._64;
> else if (strcmp(s, "a5") == 0)
>   return cpu.gpr[15]._64;
> else if (strcmp(s, "a6") == 0)
>   return cpu.gpr[16]._64;
> else if (strcmp(s, "a7") == 0)
>   return cpu.gpr[17]._64;
> else if (strcmp(s, "s2") == 0)
>   return cpu.gpr[18]._64;
> else if (strcmp(s, "s3") == 0)
>   return cpu.gpr[19]._64;
> else if (strcmp(s, "s4") == 0)
>   return cpu.gpr[20]._64;
> else if (strcmp(s, "s5") == 0)
>   return cpu.gpr[21]._64;
> else if (strcmp(s, "s6") == 0)
>   return cpu.gpr[22]._64;
> else if (strcmp(s, "s7") == 0)
>   return cpu.gpr[23]._64;
> else if (strcmp(s, "s8") == 0)
>   return cpu.gpr[24]._64;
> else if (strcmp(s, "s8") == 0)
>   return cpu.gpr[25]._64;
> else if (strcmp(s, "s10") == 0)
>   return cpu.gpr[26]._64;
> else if (strcmp(s, "t2") == 0)
>   return cpu.gpr[27]._64;
> else if (strcmp(s, "t3") == 0)
>   return cpu.gpr[28]._64;
> else if (strcmp(s, "t4") == 0)
>   return cpu.gpr[29]._64;
> else if (strcmp(s, "t5") == 0)
>   return cpu.gpr[30]._64;
> else if (strcmp(s, "t5") == 0)
>   return cpu.gpr[31]._64;
> ```
> You should be able to imagine how this student wrote the above code. Now the question is, can you quickly check if the above code is correct?
>
> And moreover, if you have a lot of code like this in your project, would you be willing to read it carefully?

<!-- > #### caution::Copy-Paste - 一种糟糕的编程习惯
> 事实上, 第一版PA发布的时候, 框架代码就恰恰是引导大家独立实现每一条指令的译码和执行过程.
> 大家在实现指令的时候, 都是把已有的代码复制好几份, 然后进行一些微小的改动(例如把`<<`改成`>>`).
> 当你发现这些代码有bug的时候, 噩梦才刚刚开始.
> 也许花了好几天你又调出一个bug的时候, 才会想起这个bug你好像之前在哪里调过.
> 你也知道代码里面还有类似的bug, 但你已经分辨不出哪些代码是什么时候从哪个地方复制过来的了.
> 由于当年的框架代码没有足够重视编程风格, 导致学生深深地陷入调试的泥淖中, 这也算是PA的一段黑历史了.
>
> 这种糟糕的编程习惯叫Copy-Paste, 经过上面的分析, 相信你也已经领略到它的可怕了.
> 事实上, [周源源教授][yyzhou]的团队在2004年就设计了一款工具CP-Miner,
> 来自动检测操作系统代码中由于Copy-Paste造成的bug.
> 这个工具还让周源源教授收获了一篇[系统方向顶级会议OSDI的论文][osdi],
> 这也是她当时所在学校UIUC史上的第一篇系统方向的顶级会议论文.
>
> 后来周源源教授发现, 相比于操作系统, 应用程序的源代码中Copy-Paste的现象更加普遍.
> 于是她们团队把CP-Miner的技术应用到应用程序的源代码中, 并创办了PatternInsight公司.
> 很多IT公司纷纷购买PatternInsight的产品, 并要求提供相应的定制服务,
> 甚至PatternInsight公司最后还被VMWare收购了.
>
> 这个故事折射出, 大公司中程序员的编程习惯也许不比你好多少,
> 他们也会写出Copy-Paste这种难以维护的代码.
> 但反过来说, 重视编码风格这些企业看中的能力, 你从现在就可以开始培养.

[yyzhou]: https://cseweb.ucsd.edu/~yyzhou/
[osdi]: http://pages.cs.wisc.edu/~shanlu/paper/OSDI04-CPMiner.pdf -->

> #### caution::Copy-Paste - A bad programming habit
>
> In fact, when the first version of PA was released, the framework code was precisely designed to guide you through the process of decoding and executing each instruction independently. Most student implemented the decoding and execution by making several copies of the existing code, and then making minor changes (e.g., changing `<<` to `>>`). The nightmare begins when you realize there is a bug in the code. It may take days just for you to uncover another bug and then remember that you've fixed it somewhere before. You know there are similar bugs in the code, but you can't tell which code was copied from which place at which time. Because the framework code did not pay enough attention to programming style, it traps students in the debugging rabbit hole, which is also a piece of PA's black history.
>
> This bad programming habit is called Copy-Paste, and after analyzing it above, I'm sure you've already realized how terrible it is. In fact, Prof. Yuan-Yuan Zhou's [team](https://cseweb.ucsd.edu/~yyzhou/)  designed a tool, CP-Miner, in 2004 to automatically detect bugs caused by Copy-Paste in OS code. This tool also allowed Prof. Zhou to publish a [paper](http://pages.cs.wisc.edu/~shanlu/paper/OSDI04-CPMiner.pdf) on the top OSDI conference. Which was also the first OSDI conference paper in the history of UIUC, where she worked at the time.
>
> Later, Prof. Yuan-Yuan Zhou discovered that copy-paste is more common in application source code than in operating systems. So her team applied CP-Miner technology to application source code and founded PatternInsight. Many IT companies purchased PatternInsight's products and asked for customized services, and PatternInsight was eventually acquired by VMWare.
>
> This story shows that programmers in big companies may be no better than you in their programming style, and that they too can write copy-paste code which is difficult to maintain. But on the other hand, emphasizing coding style is something that companies look for, and it's something you can start developing now.

<!-- 一种好的做法是把译码, 执行和操作数宽度的相关代码分离开来,
实现解耦, 也就是在程序设计课上提到的结构化程序设计.
在框架代码中, 实现译码和执行之间的解耦的是通过`INSTPAT`定义的模式匹配规则,
这样我们就可以分别编写译码和执行的内容, 然后来进行组合了:
这样的设计可以很容易实现执行行为相同但译码方式不同的多条指令.
对于x86, 实现操作数宽度和译码, 执行这两者之间的解耦的是`ISADecodeInfo`结构体中的`width`成员,
它们记录了操作数宽度, 译码和执行的过程中会根据它们进行不同的操作,
通过同一份译码和执行的代码实现不同操作数宽度的功能. -->

A good practice is to decouple the code related to decoding, execution and operand widths, which is referred to as structured programming in programming classes. In the framework code, decoupling between decoding and execution is achieved by using pattern matching rules defined by `INSTPAT`, so that we can write decoding and execution logic separately, and then combine them: this design makes it easy to implement multiple instructions with the same execution behavior but different decoding methods. For x86, the decoupling between operand width and decode/execute is achieved by the `width` members of the `ISADecodeInfo` structure, which record the operand widths. During decode and execute, we will perform different operations according to the width, so that we can handle different operand widths with the same code for decode and execute.

<!-- > #### todo::RTFSC理解指令执行的过程
> 这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节.
> 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节.
> 事实上, 配合GDB食用效果更佳.
>
> 为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:
> > 请整理一条指令在NEMU中的执行过程.
>
> 除了`nemu/src/device`和`nemu/src/isa/$ISA/system`之外,
> NEMU的其它代码你都已经有能力理解了.
> 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧!
> 在你遇到bug的时候, 这些细节就会成为帮助你调试的线索. -->

> #### todo::RTFSC Understanding the process of instruction execution
>
> This section is full of details, and you may need to read the handouts and code several times to understand each detail. According to the feedback from previous students, an effective way to understand the details is to organize them by taking notes. In fact, it's even more effective when combined with GDB.
>
> Just in case you haven't made any progress in understanding the code for a long time, let's add a mandatory question.
>
> > Please write down how an instruction is executed in NEMU.
>
> With the exception of `nemu/src/device` and `nemu/src/isa/$ISA/system`, the rest of the NEMU code you are already capable of understanding. So don't feel like you don't need to look at the files that aren't mentioned in the handout, try to understand every detail as much as you can! These details will be the clues that will help you debug when you run into a bug.

<!-- ## 运行第一个C程序 -->
## Run the first C program

<!-- 说了这么多, 现在到了动手实践的时候了.
首先克隆一个新的子项目`am-kernels`(你可能已经在PA1中克隆这个子项目了), 里面包含了一些测试程序:
```bash
cd ics2023
bash init.sh am-kernels
```
你在PA2的第一个任务, 就是实现若干条指令, 使得第一个简单的C程序可以在NEMU中运行起来.
这个简单的C程序是`am-kernels/tests/cpu-tests/tests/dummy.c`, 它什么都不做就直接返回了. -->

Having said that, it's time to get hands-on. Start by cloning a new sub-project `am-kernels` (which you may have already cloned in PA1), which contains some test programs:
```bash
cd ics2023
bash init.sh am-kernels
```
Your first task in PA2, is to implement a number of instructions to make the first simple C program run in NEMU. This simple C program is `am-kernels/tests/cpu-tests/tests/dummy.c`, and it returns without doing anything.

<!-- > #### todo::准备交叉编译环境
> 如果你选择的ISA不是x86, 你还需要准备相应的gcc和binutils, 才能正确地进行编译.
> * mips32
>   * `apt-get install g++-mips-linux-gnu binutils-mips-linux-gnu`
> * riscv32(64)
>   * `apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu` -->

> #### todo::Preparing the cross-compilation environment
>
> If you choose an ISA other than x86, you will also need to have the appropriate gcc and binutils to compile correctly.
>
> *   mips32
>     *   `apt-get install g++-mips-linux-gnu binutils-mips-linux-gnu`
> *   riscv32(64)
>     *   `apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu`

<!-- 在`am-kernels/tests/cpu-tests/`目录下键入 -->

In the `am-kernels/tests/cpu-tests/` directory type

```bash
make ARCH=$ISA-nemu ALL=dummy run
```

<!-- 编译`dummy`程序, 并启动NEMU运行它. -->

to compile the `dummy` program, and start NEMU to run it.

<!-- > #### info::修复riscv32编译错误
> 如果你选择的是riscv32, 并在编译`dummy`程序时报告了如下错误:
> ```
> /usr/riscv64-linux-gnu/include/bits/wordsize.h:28:3: error: #error "rv32i-based targets are not supported"
> ```
> 则需要使用sudo权限修改以下文件:
> ```diff
> --- /usr/riscv64-linux-gnu/include/bits/wordsize.h
> +++ /usr/riscv64-linux-gnu/include/bits/wordsize.h
> @@ -25,5 +25,5 @@
>  #if __riscv_xlen == 64
>  # define __WORDSIZE_TIME64_COMPAT32 1
>  #else
> -# error "rv32i-based targets are not supported"
> +# define __WORDSIZE_TIME64_COMPAT32 0
>  #endif
> ```
> 如果报告的是如下错误:
> ```
> /usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory
> ```
> 则需要使用sudo权限修改以下文件:
> ```diff
> --- /usr/riscv64-linux-gnu/include/gnu/stubs.h
> +++ /usr/riscv64-linux-gnu/include/gnu/stubs.h
> @@ -5,5 +5,5 @@
>  #include <bits/wordsize.h>
>
>  #if __WORDSIZE == 32 && defined __riscv_float_abi_soft
> -# include <gnu/stubs-ilp32.h>
> +//# include <gnu/stubs-ilp32.h>
>  #endif
> ``` -->

> #### info::Fix riscv32 compilation errors
> If you choose riscv32, and report the following error when compiling the `dummy` program.
> ```
> /usr/riscv64-linux-gnu/include/bits/wordsize.h:28:3: error: #error "rv32i-based targets are not supported"
> ```
> Then you need to modify the following files with sudo privileges.
> ```diff
> --- /usr/riscv64-linux-gnu/include/bits/wordsize.h
> +++ /usr/riscv64-linux-gnu/include/bits/wordsize.h
> @@ -25,5 +25,5 @@
>  #if __riscv_xlen == 64
>  # define __WORDSIZE_TIME64_COMPAT32 1
>  #else
> -# error "rv32i-based targets are not supported"
> +# define __WORDSIZE_TIME64_COMPAT32 0
>  #endif
> ```
> If the following error is reported.
> ```
> /usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory
> ```
> Then you need to modify the following files with sudo privileges.
> ```diff
> --- /usr/riscv64-linux-gnu/include/gnu/stubs.h
> +++ /usr/riscv64-linux-gnu/include/gnu/stubs.h
> @@ -5,5 +5,5 @@
>  #include <bits/wordsize.h>
>
>  #if __WORDSIZE == 32 && defined __riscv_float_abi_soft
> -# include <gnu/stubs-ilp32.h>
> +//# include <gnu/stubs-ilp32.h>
>  #endif
> ```

> #### info::What's the right way to fix errors?
> Note here modifying files directly in a tool chain is usually a quick and dirty fix which might lead to hard to find problems in the long run. Please think what is the correct way to fix the problem. You can starting by STFW for the error message and looking through the RISCV cross-compile toolchain github page.

<!-- 事实上, 并不是每一个程序都可以在NEMU中运行,
`abstract-machine`子项目专门用于编译出能在NEMU中运行的程序, 我们在下一小节中会再来介绍它. -->

In fact, not every program can run in NEMU, and the `abstract-machine` sub-project is specifically designed to compile programs to run in NEMU, which we will return to in the next sub-section.

<!-- 在NEMU中运行`dummy`程序, 你会发现NEMU输出以下信息(以riscv32为例): -->

Run the `dummy` program in NEMU, and you will find that NEMU outputs the following message (using riscv32 as an example).

```
invalid opcode(PC = 0x80000000):
        13 04 00 00 17 91 00 00 ...
        00000413 00009117...
There are two cases which will trigger this unexpected exception:
1. The instruction at PC = 0x80000000 is not implemented.
2. Something is implemented incorrectly.
Find this PC(0x80000000) in the disassembling result to distinguish which case it is.

If it is the first case, see
       _                         __  __                         _
      (_)                       |  \/  |                       | |
  _ __ _ ___  ___ ________   __ | \  / | __ _ _ __  _   _  __ _| |
 | '__| / __|/ __|______\ \ / / | |\/| |/ _` | '_ \| | | |/ _` | |
 | |  | \__ \ (__        \ V /  | |  | | (_| | | | | |_| | (_| | |
 |_|  |_|___/\___|        \_/   |_|  |_|\__,_|_| |_|\__,_|\__,_|_|

for more details.

If it is the second case, remember:
* The machine is always right!
* Every line of untested code is always wrong!
```

<!-- 这是因为你还没有实现`0x00000413`的指令, 因此, 你需要开始在NEMU中添加指令了. -->

This is because you haven't implemented the `0x00000413` instruction yet, so you need to start adding instructions to NEMU.

<!-- > #### question::为什么执行了未实现指令会出现上述报错信息
> RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做. -->

> #### question::Why does the above error message appear after executing an unimplemented instruction?
>
> RTFSC, Understand what NEMU does when executing unimplemented instructions.

<!-- 要实现哪些指令才能让`dummy`在NEMU中运行起来呢?
答案就在其反汇编结果(`am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt`)中:
你只需实现那些目前还没实现的指令就可以了.
框架代码引入的模式匹配规则, 对在NEMU中实现客户指令提供了很大的便利,
为了实现一条新指令, 你只需要在`nemu/src/isa/$ISA/inst.c`中添加正确的模式匹配规则即可. -->

What instructions should be implemented to get `dummy` up and running in NEMU? The answer is in the disassembly result (`am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt`): you only need to implement the instructions that are not currently implemented. The pattern matching rules introduced by the framework code greatly simplifies the implementation of client instructions in NEMU. In order to implement a new instruction, all you need to do is to add the correct pattern matching rules to `nemu/src/isa/$ISA/inst.c`.

<!-- > #### hint::交叉编译工具链
> 如果你选择的ISA不是x86, 在查看客户程序的二进制信息(如`objdump`, `readelf`等)时,
> 需要使用相应的交叉编译版本, 如`mips-linux-gnu-objdump`, `riscv64-linux-gnu-readelf`等.
> 特别地, 如果你选择的ISA是riscv32, 也可以使用riscv64为前缀的交叉编译工具链. -->

> #### hint::Cross-compilation toolchain
> If your ISA is not x86, you need to use the appropriate cross-compiled version of tools (e.g. `objdump`, `readelf`, etc.) to view the binary information of the client program, such as `mips-linux-gnu-objdump`, `riscv64-linux-gnu-readelf`, etc.,  In particular, if your ISA of choice is riscv32, you can also use the riscv64-prefixed cross-compiled toolchain.

<!-- 这里要再次强调, <font color=red>你务必通过RTFM来查阅指令的功能, 不能想当然.
手册中给出了指令功能的完整描述(包括做什么事, 怎么做的, 有什么影响),
一定要仔细阅读其中的每一个单词, 对指令功能理解错误和遗漏都会给以后的调试带来巨大的麻烦. </font> -->

Again, <font color=red>you must RTFM to check the function of the instruction, and not take it for granted. The manual gives a complete description of the function of the instruction (including what it does, how it does it, and what it does), so be sure to read every word carefully, as misunderstandings and omissions can cause huge problems in debugging later on.</font>

<!-- > #### hint::再提供一些x86的提示吧
> * `call`: `call`指令有很多形式, 不过在PA中只会用到其中的几种,
> 现在只需要实现`CALL rel32`的形式就可以了.
> 至于跳转地址, 框架代码里面已经有不少提示了, 也就算作是RTFSC的一个练习吧.
> * `push`: 现在只需要实现`PUSH r32`和`PUSH imm32`的形式就可以了
> *  `sub`: 在实现`sub`指令之前, 你首先需实现EFLAGS寄存器.
> 你只需要在寄存器结构体中添加EFLAGS寄存器即可.
> EFLAGS是一个32位寄存器, 但在NEMU中, 我们只会用到EFLAGS中以下的5个位:
> `CF`, `ZF`, `SF`, `IF`, `OF`, 其它位的功能可暂不实现.
> 关于EFLAGS中每一位的含义, 请查阅i386手册.
> 实现了EFLAGS寄存器之后, 你就可以实现`sub`指令了
> * `xor`, `ret`: RTFM吧 -->

> #### hint::Some more x86 tips please!
>
> * `call`: `call` instruction has many forms, but in PA will only use a few of them, just need to implement the `CALL rel32` form for now. As for the jump address, the framework code already has a lot of hints, treat it as an exercise for RTFSC.
> * `push`: Now we just need to implement `PUSH r32` and `PUSH imm32`.
> * `sub`: Before implementing the `sub` instruction, you first need to implement the EFLAGS register. You just need to add the EFLAGS register to the register structure. EFLAGS is a 32-bit register, but in NEMU, we will only use the following five bits in EFLAGS: `CF`, `ZF`, `SF`, `IF`, `OF`, so the rest of the bits can be left unimplemented. Please refer to the i386 manual for the meaning of each bit in the EFLAGS register. Once you have implemented the EFLAGS register, you can implement the `sub` instructions
> * `xor`, `ret`: RTFM it.

<!-- > #### todo::运行第一个客户程序
> 在NEMU中实现上文提到的指令, 具体细节请务必参考手册.
> 实现成功后, 在NEMU中运行客户程序`dummy`, 你将会看到`HIT GOOD TRAP`的信息.
> 如果你没有看到这一信息, 说明你的指令实现不正确,
> 你可以使用PA1中实现的简易调试器帮助你调试. -->

> #### todo::Run the first client program
>
> Implement the above mentioned commands in NEMU, please be sure to refer to the manual for details. After successful implementation, run the client program `dummy` in NEMU, you will see the message `HIT GOOD TRAP`. If you don't see this message, your implementation is incorrect, and you can use the simple debugger implemented in PA1 to help you debug it.

<!-- ## 运行更多的程序 -->
## Run more programs

<!-- 未测试代码永远是错的, 你需要更多的测试用例来测试你的NEMU.
我们在`am-kernels/tests/cpu-tests/`目录下准备了一些简单的测试用例.
在该目录下执行 -->

Untested code is always wrong, you need more test cases to test your NEMU. We have prepared some simple test cases in the `am-kernels/tests/cpu-tests/` directory. In that directory, run

```bash
make ARCH=$ISA-nemu ALL=xxx run
```

<!-- 其中`xxx`为测试用例的名称(不包含`.c`后缀).

上述`make run`的命令最终会启动NEMU, 并运行相应的客户程序.
如果你需要使用GDB来调试NEMU运行客户程序的情况, 可以执行以下命令: -->

where `xxx` is the name of the test case (without the `.c` suffix).

The above `make run` command will eventually start NEMU and run the corresponding client program. If you need to use GDB to debug NEMU running client programs, you can execute the following command.

```bash
make ARCH=$ISA-nemu ALL=xxx gdb
```

<!-- > #### todo::实现更多的指令
> 你需要实现更多的指令, 以通过上述测试用例.
>
> 你可以自由选择按照什么顺序来实现指令.
> 经过PA1的训练之后, 你应该不会实现所有指令之后才进行测试了.
> 要养成尽早做测试的好习惯, 一般原则都是"实现尽可能少的指令来进行下一次的测试".
> 你不需要实现所有指令的所有形式, 只需要通过这些测试即可.
> 如果将来仍然遇到了未实现的指令, 就到时候再实现它们.
>
> 框架代码已经实现了部分指令, 但可能未编写相应的模式匹配规则.
> 此外, 部分函数的功能也并没有完全实现好(框架代码中已经插入了`TODO()`作为提示),
> 你还需要编写相应的功能.
>
> 由于`string`和`hello-str`还需要实现额外的内容才能运行(具体在后续小节介绍),
> 目前可以先使用其它测试用例进行测试. -->

> #### todo::Implement more commands
>
> You need to implement more commands in order to pass the above test cases.
>
> You are free to choose the order in which you want to implement the instructions. After training in PA1, you probably won't implement all the commands before testing them. It's good to get into the habit of testing as early as possible, and the general rule is "implement as few instructions as possible for the next test". You don't need to implement all the instructions in all their forms, you just need to pass these tests. If you still encounter unimplemented directives in the future, implement them then.
>
> The framework code already implements some of the instructions, but may not have written the corresponding pattern-matching rules. Also, some of the functions are not fully implemented (the framework code has inserted `TODO()` as a hint), and you will need to write the corresponding functions.
>
> Since `string` and `hello-str` need additional implementation to work (described in the following subsections), you can use other test cases for now.

<!-- > #### caution::不要以为只需要在TODO处写代码
> 过去经常有同学认为, "我只需要在出现`TODO`的地方写代码就可以了,
> 如果一个功能在框架代码中没有相应的`TODO`, 它就是超出必做内容的范围, 我不需要实现."
>
> <font color=red>在PA中, 这种想法是错误的.</font>
> 如果你RTFSC, 你会发现`TODO()`只是个宏, 展开之后会调用`panic()`.
> 因此框架代码中的`TODO`更多地是在NEMU运行的时候给出可读性更好的结果(如xxx未实现),
> 而不是让NEMU触发让你畏惧的段错误.
>
> 你毕业后进入公司/课题组, 不会再有讲义具体地告诉你应该做什么,
> 总有一天你需要在脱离讲义的情况下完成任务.
> 我们希望你现在就放弃"讲义和框架代码会把我应该做的一切细节清楚地告诉我"的幻想,
> 为自己承担起"理解整个系统工作原理"的责任, 而不是成为框架代码的奴仆.
> 因此, 当你疑惑一个功能是否需要实现时, 你不应该通过框架代码中是否有`TODO`来进行判断,
> 而是应该根据你对代码的理解和当下的需求来做决定. -->

> #### caution::Don't think you only need to write code at the TODO
>
> In the past, students often thought, "I only need to write code wherever a `TODO` appears, and if a feature doesn't have a corresponding `TODO` in the framework code, it's beyond the scope of must-do content, and I don't need to implement it."
>
> <font color=red>In PA, this kind of thinking is wrong.</font> If you RTFSC, you'll see that `TODO()` is just a macro that expands and calls `panic()`. So the `TODO` in the framework code is more about giving better readable results (e.g. xxx is not implemented) when NEMU runs, rather than making NEMU trigger segmentation errors that make you cringe.
>
> When you graduate and join a company/project team, there will be no more handouts telling you exactly what to do, and there will come a time when you will have to do things independently. We want you to give up the illusion that the handouts and framework code will tell me everything I need to do in detail, and take responsibility for "understanding how the system works", rather than becoming a slave to the framework code. Therefore, when you are wondering whether a feature needs to be implemented, you should not judge it by the presence of a `TODO` in the framework code, but rather make a decision based on your understanding of the code and the needs of the moment.

<!-- > #### danger::x86指令相关的注意事项
> * `push imm8`指令行为补充. `push imm8`指令需要对立即数进行符号扩展,
>   这一点在i386手册中并没有明确说明. 在[IA-32手册][ia32]中关于`push`指令有如下说明:
> > If the source operand is an immediate and its size is less than the operand size,
> > a sign-extended value is pushed on the stack.
> * 字符串操作指令. 如`movsb`等, 这些指令需要用到段寄存器`DS`, `ES`以及EFLAGS寄存器中的`DF`标志.
>   在PA中无需实现这些寄存器, RTFM时认为这些寄存器的值恒为`0`来理解指令的语义即可.
> * `endbr32`指令. 具体见[这里](2.2.md#去除endbr32指令)

[ia32]: http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf -->

> #### danger::Notes related to x86 instructions
>
> *  The `push imm8` instruction requires a sign extension for immediate numbers, which is not explicitly stated in the i386 manual. In [IA-32 manual](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf) it describes `push` as follow.
>
> > If the source operand is an immediate and its size is less than the operand size, a sign-extended value is pushed on the stack.
>
> *   String manipulation instructions.  Such as `movsb`, these instructions require the segment registers `DS`, `ES` and the `DF` flag in the EFLAGS register. There is no need to implement these registers in PA, and when RTFM you can assume that the value of these registers is always `0` to understand the semantics of the instruction.
> *   The `endbr32` command.  See [here](2.2.html#%E5%8E%BB%E9%99%A4endbr32%E6%8C%87%E4%BB%A4) for details

<!-- > #### question::mips32的分支延迟槽
> 为了提升处理器的性能, mips使用了一种叫[分支延迟槽][delay slot]的技术.
> 采用这种技术之后, 程序的执行顺序会发生一些改变:
> 我们把紧跟在跳转指令(包括有条件和无条件)之后的静态指令称为延迟槽,
> 那么程序在执行完跳转指令后, 会先执行延迟槽中的指令,
> 再执行位于跳转目标的指令. 例如
> ```
> 100: beq 200
> 101: add
> 102: xor
> ...
> 200: sub
> 201: j   102
> 202: slt
> ```
> 若`beq`指令的执行结果为跳转, 则相应的动态指令流为`100 -> 101 -> 200`;
> 若`beq`指令的执行结果为不跳转, 则相应的动态指令流为`100 -> 101 -> 102`;
> 而对于`j`指令, 相应的动态指令流为`201 -> 202 -> 102`.
>
> 你一定会对这种反直觉的技术如何提升处理器性能而感到疑惑.
> 不过这需要你先了解一些微结构的知识, 例如[处理器流水线][pipeline],
> 但这已经超出了ICS的课程范围了, 所以我们也不详细解释了, 感兴趣的话可以STFW.
>
> 但我们可以知道, 延迟槽技术需要软硬件协同才能正确工作:
> mips手册中描述了这一约定, 处理器设计者按照这一约定设计处理器,
> 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令,
> 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.
>
> 如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?

[pipeline]: http://en.wikipedia.org/wiki/Classic_RISC_pipeline
[delay slot]: https://en.wikipedia.org/wiki/Delay_slot -->

> #### question::Branch delay slot for mips32
>
> In order to improve processor performance, mips uses a technique called [branch delay slot](https://en.wikipedia.org/wiki/Delay_slot). With this technique, the execution order of the program changes a bit: we call the static instructions immediately after the jump instructions (both conditional and unconditional) the delay slots, then program will first execute the instructions in the delay slots after the jump instructions, then execute the instructions in the jump target. For example
> ```
> 100: beq 200
> 101: add
> 102: xor
> ...
> 200: sub
> 201: j   102
> 202: slt
> ```
> If the execution of the `beq` instruction results in a jump, the corresponding dynamic instruction flow is `100 -> 101 -> 200`; if the execution of the `beq` instruction results in no jump, the corresponding dynamic instruction flow is `100 -> 101 -> 102`; and for the `j` instruction, the corresponding dynamic instruction flow is `201 -> 202 -> 102`.
>
> You must be wondering how this counter-intuitive technique can improve processor performance. It requires some knowledge of microarchitecture, such as [processor pipelining](http://en.wikipedia.org/wiki/Classic_RISC_pipeline), but that's beyond the scope of the ICS course, so we won't explain it in detail, and you can STFW if you're interested.
>
> But we know that delay slots require hardware and software collaboration to work correctly: the mips manual describes the convention, the processor designer designs the processor according to this convention, and the compiler developer makes the compiler responsible for placing a meaningful instruction in a delay slot, so that the sequence of execution according to this convention results in the correct execution, regardless of whether or not there is a jump.
>
> If you were a compiler developer, how would you find the right instruction to put in the delay slot?

<!-- > #### comment::mips32-NEMU的分支延迟槽
> 既然mips有这样的约定, 而编译器也已经遵循这一约定,
> 那么对于mips32编译器生成的程序, 我们也应该遵循这一约定来解释其语义.
> 这意味着, mips32-NEMU作为一个模拟的mips32 CPU, 也需要实现分支延迟槽技术,
> 才能正确地支撑mips32程序的运行.
>
> 事实上, gcc为mips32程序的生成提供了一个`-fno-delayed-branch`的编译选项,
> 让mips32程序中的延迟槽中都放置`nop`指令.
> 这样以后, 执行跳转指令之后, 接下来就可以直接执行跳转目标的指令了,
> 因为延迟槽中都是`nop`指令, 就算不执行它, 也不会影响程序的正确性.
>
> 我们已经在编译mips32程序的命令中添加了这一编译选项,
> 于是我们在实现mips32-NEMU的时候就可以进行简化, 无需实现分支延迟槽了.
>
> 对PA来说, 去掉延迟槽还有其它的好处, 我们会在后续内容中进行讨论. -->

> #### comment::Branch delay slot for mips32-NEMU
>
> Since mips has such a convention, and the compiler has followed it, we should also follow this convention in interpreting the semantics of programs generated by the mips32 compiler. This means that mips32-NEMU, as an emulated mips32 CPU, also needs to implement branch delay slot technology in order to properly support mips32 programs.
>
> In fact, gcc provides a `-fno-delayed-branch` compilation option for mips32 program, so that `nop` instructions are placed in all delay slots in the mips32 program. This way, after executing the jump instruction, the next instruction can be executed directly at the jump target. Since the delay slots are filled with `nop` instructions, the correctness of the program will not be affected even if you don't execute them.
>
> We have added this compilation option to the command that compiles the mips32 program, so we can simplify the implementation of mips32-NEMU by eliminating the need to implement branch delay slots.
>
> There are other benefits to PAs of removing delay slots, which we will discuss in a later section.

<!-- > #### question::指令名对照
> AT&T格式反汇编结果中的少量指令, 与手册中列出的指令名称不符,
> 如x86的`cltd`, mips32和riscv32则有不少伪指令(pseudo instruction).
> 除了STFW之外, 你有办法在手册中找到对应的指令吗?
> 如果有的话, 为什么这个办法是有效的呢? -->

> #### question::command name cross-reference
>
> There are a few instructions in the AT&T format disassembly results that don't match the names of the instructions listed in the manual, e.g., `cltd` for x86, and a number of pseudo instructions for mips32 and riscv32. Do you have a way to find the corresponding instructions in the manual other than STFW? If so, why does this work?

<!-- > #### flag::温馨提示
> PA2阶段1到此结束. -->

> #### flag::Hint
> This concludes phase 1 of PA2.
